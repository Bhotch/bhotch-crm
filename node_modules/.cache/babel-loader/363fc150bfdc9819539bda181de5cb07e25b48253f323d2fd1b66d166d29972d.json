{"ast":null,"code":"import _objectSpread from\"C:/Users/PC_User/Desktop/free-crm/bhotch-crm/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import cacheManager from'./advancedCache';import securityManager from'./securityManager';import logger from'./enterpriseLogger';class BackupRecoverySystem{constructor(){this.backupPrefix='backup_';this.maxBackups=10;this.autoBackupInterval=6*60*60*1000;// 6 hours\nthis.compressionThreshold=10000;// bytes\nthis.encryptionEnabled=true;this.initializeBackupSystem();}initializeBackupSystem(){// Schedule automatic backups\nthis.scheduleAutoBackups();// Listen for critical data changes\nthis.setupDataChangeListeners();// Register cleanup tasks\nthis.scheduleCleanup();logger.info('Backup and Recovery System initialized',{autoBackupInterval:this.autoBackupInterval,maxBackups:this.maxBackups,encryptionEnabled:this.encryptionEnabled});}scheduleAutoBackups(){setInterval(async()=>{try{await this.createAutoBackup();logger.info('Automatic backup completed successfully');}catch(error){logger.error('Automatic backup failed',{error:error.message});}},this.autoBackupInterval);// Create initial backup after 30 seconds\nsetTimeout(()=>this.createAutoBackup(),30000);}setupDataChangeListeners(){// Listen for storage events\nwindow.addEventListener('storage',event=>{if(this.isCriticalData(event.key)){this.scheduleIncrementalBackup(event.key);}});// Listen for beforeunload to create emergency backup\nwindow.addEventListener('beforeunload',()=>{this.createEmergencyBackup();});}scheduleCleanup(){// Clean old backups daily\nsetInterval(()=>{this.cleanupOldBackups();},24*60*60*1000);}isCriticalData(key){const criticalPrefixes=['leads_','jobCounts_','calculations_','userSettings_'];return criticalPrefixes.some(prefix=>key===null||key===void 0?void 0:key.startsWith(prefix));}async createFullBackup(){let backupName=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;const startTime=performance.now();try{const backupId=backupName||\"full_\".concat(Date.now());const timestamp=new Date().toISOString();logger.info('Starting full backup',{backupId});// Collect all data sources\nconst backupData={metadata:{backupId,timestamp,type:'full',version:'1.0',source:'Ultimate CRM'},localStorage:await this.backupLocalStorage(),sessionStorage:await this.backupSessionStorage(),indexedDB:await this.backupIndexedDB(),cache:await this.backupCacheData(),settings:await this.backupUserSettings(),calculations:await this.backupCalculations()};// Calculate backup size and checksum\nconst serializedData=JSON.stringify(backupData);backupData.metadata.size=serializedData.length;backupData.metadata.checksum=this.calculateChecksum(serializedData);// Compress if needed\nconst finalData=this.shouldCompress(serializedData)?this.compressData(backupData):backupData;// Encrypt backup\nconst encryptedBackup=this.encryptionEnabled?securityManager.encryptBackupData(finalData):finalData;// Store backup\nconst backupKey=\"\".concat(this.backupPrefix).concat(backupId);await this.storeBackup(backupKey,encryptedBackup);// Update backup registry\nawait this.updateBackupRegistry(backupId,{timestamp,type:'full',size:backupData.metadata.size,compressed:this.shouldCompress(serializedData),encrypted:this.encryptionEnabled});const duration=performance.now()-startTime;logger.info('Full backup completed',{backupId,duration:Math.round(duration),size:backupData.metadata.size,compressed:this.shouldCompress(serializedData)});return{success:true,backupId,size:backupData.metadata.size,duration};}catch(error){const duration=performance.now()-startTime;logger.error('Full backup failed',{error:error.message,duration:Math.round(duration)});return{success:false,error:error.message,duration};}}async createIncrementalBackup(){let changedKeys=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];const startTime=performance.now();try{const backupId=\"incremental_\".concat(Date.now());const timestamp=new Date().toISOString();logger.info('Starting incremental backup',{backupId,changedKeys});const backupData={metadata:{backupId,timestamp,type:'incremental',version:'1.0',changedKeys},changes:{}};// Backup only changed data\nfor(const key of changedKeys){if(key.startsWith('localStorage_')){const actualKey=key.substring(13);backupData.changes[key]=localStorage.getItem(actualKey);}else if(key.startsWith('sessionStorage_')){const actualKey=key.substring(15);backupData.changes[key]=sessionStorage.getItem(actualKey);}}const serializedData=JSON.stringify(backupData);backupData.metadata.size=serializedData.length;backupData.metadata.checksum=this.calculateChecksum(serializedData);const encryptedBackup=this.encryptionEnabled?securityManager.encryptBackupData(backupData):backupData;const backupKey=\"\".concat(this.backupPrefix).concat(backupId);await this.storeBackup(backupKey,encryptedBackup);await this.updateBackupRegistry(backupId,{timestamp,type:'incremental',size:backupData.metadata.size,changedKeys});const duration=performance.now()-startTime;logger.info('Incremental backup completed',{backupId,duration:Math.round(duration),size:backupData.metadata.size});return{success:true,backupId,size:backupData.metadata.size};}catch(error){logger.error('Incremental backup failed',{error:error.message});return{success:false,error:error.message};}}async createAutoBackup(){return await this.createFullBackup(\"auto_\".concat(Date.now()));}createEmergencyBackup(){// Synchronous emergency backup using basic localStorage\ntry{const emergencyData={timestamp:Date.now(),localStorage:_objectSpread({},localStorage),sessionStorage:_objectSpread({},sessionStorage)};localStorage.setItem('emergencyBackup',JSON.stringify(emergencyData));logger.info('Emergency backup created');}catch(error){console.error('Emergency backup failed:',error);}}async scheduleIncrementalBackup(changedKey){// Debounce multiple rapid changes\nif(this.incrementalTimeout){clearTimeout(this.incrementalTimeout);}if(!this.changedKeys){this.changedKeys=new Set();}this.changedKeys.add(changedKey);this.incrementalTimeout=setTimeout(async()=>{const keys=Array.from(this.changedKeys);this.changedKeys.clear();await this.createIncrementalBackup(keys);},30000);// 30 second delay\n}async restoreFromBackup(backupId){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const startTime=performance.now();try{const{dryRun=false,skipConfirmation=false,selectiveRestore=null}=options;logger.info('Starting restore operation',{backupId,dryRun});if(!skipConfirmation&&!dryRun){const confirmed=window.confirm(\"Are you sure you want to restore from backup \\\"\".concat(backupId,\"\\\"? This will overwrite current data.\"));if(!confirmed){return{success:false,cancelled:true};}}// Retrieve backup\nconst backupKey=\"\".concat(this.backupPrefix).concat(backupId);const encryptedBackup=await this.retrieveBackup(backupKey);if(!encryptedBackup){throw new Error(\"Backup \\\"\".concat(backupId,\"\\\" not found\"));}// Decrypt backup\nconst backupData=this.encryptionEnabled?securityManager.decryptSensitiveData(encryptedBackup):encryptedBackup;// Validate backup integrity\nconst isValid=await this.validateBackupIntegrity(backupData);if(!isValid){throw new Error('Backup integrity validation failed');}if(dryRun){return{success:true,dryRun:true,metadata:backupData.metadata,dataKeys:Object.keys(backupData).filter(key=>key!=='metadata')};}// Create pre-restore backup\nawait this.createFullBackup(\"pre_restore_\".concat(Date.now()));// Perform restoration\nawait this.performRestore(backupData,selectiveRestore);const duration=performance.now()-startTime;logger.info('Restore completed successfully',{backupId,duration:Math.round(duration)});return{success:true,backupId,restoredAt:new Date().toISOString(),duration};}catch(error){const duration=performance.now()-startTime;logger.error('Restore operation failed',{backupId,error:error.message,duration:Math.round(duration)});return{success:false,error:error.message,duration};}}async performRestore(backupData,selectiveRestore){const{metadata,localStorage:lsData,sessionStorage:ssData,indexedDB,cache}=backupData;// Restore localStorage\nif((!selectiveRestore||selectiveRestore.includes('localStorage'))&&lsData){Object.entries(lsData).forEach(_ref=>{let[key,value]=_ref;if(value!==null){localStorage.setItem(key,value);}});}// Restore sessionStorage\nif((!selectiveRestore||selectiveRestore.includes('sessionStorage'))&&ssData){Object.entries(ssData).forEach(_ref2=>{let[key,value]=_ref2;if(value!==null){sessionStorage.setItem(key,value);}});}// Restore IndexedDB\nif((!selectiveRestore||selectiveRestore.includes('indexedDB'))&&indexedDB){await this.restoreIndexedDB(indexedDB);}// Restore cache\nif((!selectiveRestore||selectiveRestore.includes('cache'))&&cache){await this.restoreCache(cache);}logger.info('Data restoration completed',{restoredSections:selectiveRestore||['all']});}async backupLocalStorage(){const data={};for(let i=0;i<localStorage.length;i++){const key=localStorage.key(i);data[key]=localStorage.getItem(key);}return data;}async backupSessionStorage(){const data={};for(let i=0;i<sessionStorage.length;i++){const key=sessionStorage.key(i);data[key]=sessionStorage.getItem(key);}return data;}async backupIndexedDB(){try{// Backup cache database\nconst cacheKeys=await cacheManager.keys('*');const cacheData={};for(const key of cacheKeys){cacheData[key]=await cacheManager.get(key);}return cacheData;}catch(error){logger.warn('IndexedDB backup failed',{error:error.message});return{};}}async backupCacheData(){try{return await cacheManager.getStats();}catch(error){logger.warn('Cache backup failed',{error:error.message});return{};}}async backupUserSettings(){return{theme:localStorage.getItem('theme'),language:localStorage.getItem('language'),preferences:localStorage.getItem('userPreferences'),settings:localStorage.getItem('appSettings')};}async backupCalculations(){try{const calculationKeys=await cacheManager.keys('calculation:*');const calculations={};for(const key of calculationKeys){calculations[key]=await cacheManager.get(key);}return calculations;}catch(error){logger.warn('Calculations backup failed',{error:error.message});return{};}}async restoreIndexedDB(indexedDBData){try{for(const[key,value]of Object.entries(indexedDBData)){await cacheManager.set(key,value,{ttl:24*60*60*1000});}}catch(error){logger.error('IndexedDB restore failed',{error:error.message});}}async restoreCache(cacheData){try{// Cache stats are informational only, no restoration needed\nlogger.info('Cache stats from backup',cacheData);}catch(error){logger.error('Cache restore failed',{error:error.message});}}shouldCompress(data){return data.length>this.compressionThreshold;}compressData(data){try{return{compressed:true,data:JSON.stringify(data)// Simple JSON compression\n};}catch(error){logger.warn('Compression failed',{error:error.message});return data;}}decompressData(compressedData){try{if(compressedData.compressed){return JSON.parse(compressedData.data);}return compressedData;}catch(error){logger.error('Decompression failed',{error:error.message});return compressedData;}}calculateChecksum(data){let hash=0;for(let i=0;i<data.length;i++){const char=data.charCodeAt(i);hash=(hash<<5)-hash+char;hash=hash&hash;}return hash.toString(16);}async validateBackupIntegrity(backupData){try{if(!backupData.metadata){logger.warn('Backup missing metadata');return false;}const{checksum,size}=backupData.metadata;const currentData=JSON.stringify(backupData);if(size&&currentData.length!==size){logger.warn('Backup size mismatch',{expected:size,actual:currentData.length});}if(checksum){const currentChecksum=this.calculateChecksum(currentData);if(currentChecksum!==checksum){logger.error('Backup checksum validation failed',{expected:checksum,actual:currentChecksum});return false;}}return true;}catch(error){logger.error('Backup validation failed',{error:error.message});return false;}}async storeBackup(key,data){await cacheManager.set(key,data,{ttl:30*24*60*60*1000,// 30 days\ntags:['backup']});}async retrieveBackup(key){return await cacheManager.get(key);}async updateBackupRegistry(backupId,metadata){try{const registry=(await cacheManager.get('backup_registry'))||{};registry[backupId]=metadata;await cacheManager.set('backup_registry',registry,{ttl:30*24*60*60*1000,tags:['backup','registry']});}catch(error){logger.error('Failed to update backup registry',{error:error.message});}}async getBackupList(){try{const registry=(await cacheManager.get('backup_registry'))||{};return Object.entries(registry).map(_ref3=>{let[id,metadata]=_ref3;return _objectSpread({id},metadata);}).sort((a,b)=>new Date(b.timestamp)-new Date(a.timestamp));}catch(error){logger.error('Failed to get backup list',{error:error.message});return[];}}async deleteBackup(backupId){try{const backupKey=\"\".concat(this.backupPrefix).concat(backupId);await cacheManager.delete(backupKey);const registry=(await cacheManager.get('backup_registry'))||{};delete registry[backupId];await cacheManager.set('backup_registry',registry);logger.info('Backup deleted',{backupId});return{success:true};}catch(error){logger.error('Failed to delete backup',{backupId,error:error.message});return{success:false,error:error.message};}}async cleanupOldBackups(){try{const backups=await this.getBackupList();const backupsToDelete=backups.slice(this.maxBackups);for(const backup of backupsToDelete){await this.deleteBackup(backup.id);}logger.info('Backup cleanup completed',{totalBackups:backups.length,deletedBackups:backupsToDelete.length,remainingBackups:Math.min(backups.length,this.maxBackups)});return backupsToDelete.length;}catch(error){logger.error('Backup cleanup failed',{error:error.message});return 0;}}async getSystemHealth(){try{const backups=await this.getBackupList();const lastBackup=backups[0];const backupStats=await cacheManager.getStats();return{totalBackups:backups.length,lastBackup:lastBackup?{id:lastBackup.id,timestamp:lastBackup.timestamp,type:lastBackup.type,size:lastBackup.size}:null,autoBackupEnabled:!!this.autoBackupInterval,nextAutoBackup:this.getNextBackupTime(),storageHealth:backupStats,encryptionEnabled:this.encryptionEnabled};}catch(error){logger.error('Failed to get system health',{error:error.message});return{error:error.message};}}getNextBackupTime(){// Calculate next auto backup time\nconst now=Date.now();const lastAutoBackupTime=this.lastAutoBackupTime||now;return new Date(lastAutoBackupTime+this.autoBackupInterval).toISOString();}destroy(){if(this.incrementalTimeout){clearTimeout(this.incrementalTimeout);}logger.info('Backup and Recovery System destroyed');}}const backupRecoverySystem=new BackupRecoverySystem();export default backupRecoverySystem;export{BackupRecoverySystem};","map":{"version":3,"names":["cacheManager","securityManager","logger","BackupRecoverySystem","constructor","backupPrefix","maxBackups","autoBackupInterval","compressionThreshold","encryptionEnabled","initializeBackupSystem","scheduleAutoBackups","setupDataChangeListeners","scheduleCleanup","info","setInterval","createAutoBackup","error","message","setTimeout","window","addEventListener","event","isCriticalData","key","scheduleIncrementalBackup","createEmergencyBackup","cleanupOldBackups","criticalPrefixes","some","prefix","startsWith","createFullBackup","backupName","arguments","length","undefined","startTime","performance","now","backupId","concat","Date","timestamp","toISOString","backupData","metadata","type","version","source","localStorage","backupLocalStorage","sessionStorage","backupSessionStorage","indexedDB","backupIndexedDB","cache","backupCacheData","settings","backupUserSettings","calculations","backupCalculations","serializedData","JSON","stringify","size","checksum","calculateChecksum","finalData","shouldCompress","compressData","encryptedBackup","encryptBackupData","backupKey","storeBackup","updateBackupRegistry","compressed","encrypted","duration","Math","round","success","createIncrementalBackup","changedKeys","changes","actualKey","substring","getItem","emergencyData","_objectSpread","setItem","console","changedKey","incrementalTimeout","clearTimeout","Set","add","keys","Array","from","clear","restoreFromBackup","options","dryRun","skipConfirmation","selectiveRestore","confirmed","confirm","cancelled","retrieveBackup","Error","decryptSensitiveData","isValid","validateBackupIntegrity","dataKeys","Object","filter","performRestore","restoredAt","lsData","ssData","includes","entries","forEach","_ref","value","_ref2","restoreIndexedDB","restoreCache","restoredSections","data","i","cacheKeys","cacheData","get","warn","getStats","theme","language","preferences","calculationKeys","indexedDBData","set","ttl","decompressData","compressedData","parse","hash","char","charCodeAt","toString","currentData","expected","actual","currentChecksum","tags","registry","getBackupList","map","_ref3","id","sort","a","b","deleteBackup","delete","backups","backupsToDelete","slice","backup","totalBackups","deletedBackups","remainingBackups","min","getSystemHealth","lastBackup","backupStats","autoBackupEnabled","nextAutoBackup","getNextBackupTime","storageHealth","lastAutoBackupTime","destroy","backupRecoverySystem"],"sources":["C:/Users/PC_User/Desktop/free-crm/bhotch-crm/src/utils/backupRecoverySystem.js"],"sourcesContent":["import cacheManager from './advancedCache';\r\nimport securityManager from './securityManager';\r\nimport logger from './enterpriseLogger';\r\n\r\nclass BackupRecoverySystem {\r\n  constructor() {\r\n    this.backupPrefix = 'backup_';\r\n    this.maxBackups = 10;\r\n    this.autoBackupInterval = 6 * 60 * 60 * 1000; // 6 hours\r\n    this.compressionThreshold = 10000; // bytes\r\n    this.encryptionEnabled = true;\r\n\r\n    this.initializeBackupSystem();\r\n  }\r\n\r\n  initializeBackupSystem() {\r\n    // Schedule automatic backups\r\n    this.scheduleAutoBackups();\r\n\r\n    // Listen for critical data changes\r\n    this.setupDataChangeListeners();\r\n\r\n    // Register cleanup tasks\r\n    this.scheduleCleanup();\r\n\r\n    logger.info('Backup and Recovery System initialized', {\r\n      autoBackupInterval: this.autoBackupInterval,\r\n      maxBackups: this.maxBackups,\r\n      encryptionEnabled: this.encryptionEnabled\r\n    });\r\n  }\r\n\r\n  scheduleAutoBackups() {\r\n    setInterval(async () => {\r\n      try {\r\n        await this.createAutoBackup();\r\n        logger.info('Automatic backup completed successfully');\r\n      } catch (error) {\r\n        logger.error('Automatic backup failed', { error: error.message });\r\n      }\r\n    }, this.autoBackupInterval);\r\n\r\n    // Create initial backup after 30 seconds\r\n    setTimeout(() => this.createAutoBackup(), 30000);\r\n  }\r\n\r\n  setupDataChangeListeners() {\r\n    // Listen for storage events\r\n    window.addEventListener('storage', (event) => {\r\n      if (this.isCriticalData(event.key)) {\r\n        this.scheduleIncrementalBackup(event.key);\r\n      }\r\n    });\r\n\r\n    // Listen for beforeunload to create emergency backup\r\n    window.addEventListener('beforeunload', () => {\r\n      this.createEmergencyBackup();\r\n    });\r\n  }\r\n\r\n  scheduleCleanup() {\r\n    // Clean old backups daily\r\n    setInterval(() => {\r\n      this.cleanupOldBackups();\r\n    }, 24 * 60 * 60 * 1000);\r\n  }\r\n\r\n  isCriticalData(key) {\r\n    const criticalPrefixes = ['leads_', 'jobCounts_', 'calculations_', 'userSettings_'];\r\n    return criticalPrefixes.some(prefix => key?.startsWith(prefix));\r\n  }\r\n\r\n  async createFullBackup(backupName = null) {\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      const backupId = backupName || `full_${Date.now()}`;\r\n      const timestamp = new Date().toISOString();\r\n\r\n      logger.info('Starting full backup', { backupId });\r\n\r\n      // Collect all data sources\r\n      const backupData = {\r\n        metadata: {\r\n          backupId,\r\n          timestamp,\r\n          type: 'full',\r\n          version: '1.0',\r\n          source: 'Ultimate CRM'\r\n        },\r\n        localStorage: await this.backupLocalStorage(),\r\n        sessionStorage: await this.backupSessionStorage(),\r\n        indexedDB: await this.backupIndexedDB(),\r\n        cache: await this.backupCacheData(),\r\n        settings: await this.backupUserSettings(),\r\n        calculations: await this.backupCalculations()\r\n      };\r\n\r\n      // Calculate backup size and checksum\r\n      const serializedData = JSON.stringify(backupData);\r\n      backupData.metadata.size = serializedData.length;\r\n      backupData.metadata.checksum = this.calculateChecksum(serializedData);\r\n\r\n      // Compress if needed\r\n      const finalData = this.shouldCompress(serializedData) ?\r\n        this.compressData(backupData) : backupData;\r\n\r\n      // Encrypt backup\r\n      const encryptedBackup = this.encryptionEnabled ?\r\n        securityManager.encryptBackupData(finalData) : finalData;\r\n\r\n      // Store backup\r\n      const backupKey = `${this.backupPrefix}${backupId}`;\r\n      await this.storeBackup(backupKey, encryptedBackup);\r\n\r\n      // Update backup registry\r\n      await this.updateBackupRegistry(backupId, {\r\n        timestamp,\r\n        type: 'full',\r\n        size: backupData.metadata.size,\r\n        compressed: this.shouldCompress(serializedData),\r\n        encrypted: this.encryptionEnabled\r\n      });\r\n\r\n      const duration = performance.now() - startTime;\r\n      logger.info('Full backup completed', {\r\n        backupId,\r\n        duration: Math.round(duration),\r\n        size: backupData.metadata.size,\r\n        compressed: this.shouldCompress(serializedData)\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        backupId,\r\n        size: backupData.metadata.size,\r\n        duration\r\n      };\r\n\r\n    } catch (error) {\r\n      const duration = performance.now() - startTime;\r\n      logger.error('Full backup failed', {\r\n        error: error.message,\r\n        duration: Math.round(duration)\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        error: error.message,\r\n        duration\r\n      };\r\n    }\r\n  }\r\n\r\n  async createIncrementalBackup(changedKeys = []) {\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      const backupId = `incremental_${Date.now()}`;\r\n      const timestamp = new Date().toISOString();\r\n\r\n      logger.info('Starting incremental backup', { backupId, changedKeys });\r\n\r\n      const backupData = {\r\n        metadata: {\r\n          backupId,\r\n          timestamp,\r\n          type: 'incremental',\r\n          version: '1.0',\r\n          changedKeys\r\n        },\r\n        changes: {}\r\n      };\r\n\r\n      // Backup only changed data\r\n      for (const key of changedKeys) {\r\n        if (key.startsWith('localStorage_')) {\r\n          const actualKey = key.substring(13);\r\n          backupData.changes[key] = localStorage.getItem(actualKey);\r\n        } else if (key.startsWith('sessionStorage_')) {\r\n          const actualKey = key.substring(15);\r\n          backupData.changes[key] = sessionStorage.getItem(actualKey);\r\n        }\r\n      }\r\n\r\n      const serializedData = JSON.stringify(backupData);\r\n      backupData.metadata.size = serializedData.length;\r\n      backupData.metadata.checksum = this.calculateChecksum(serializedData);\r\n\r\n      const encryptedBackup = this.encryptionEnabled ?\r\n        securityManager.encryptBackupData(backupData) : backupData;\r\n\r\n      const backupKey = `${this.backupPrefix}${backupId}`;\r\n      await this.storeBackup(backupKey, encryptedBackup);\r\n\r\n      await this.updateBackupRegistry(backupId, {\r\n        timestamp,\r\n        type: 'incremental',\r\n        size: backupData.metadata.size,\r\n        changedKeys\r\n      });\r\n\r\n      const duration = performance.now() - startTime;\r\n      logger.info('Incremental backup completed', {\r\n        backupId,\r\n        duration: Math.round(duration),\r\n        size: backupData.metadata.size\r\n      });\r\n\r\n      return { success: true, backupId, size: backupData.metadata.size };\r\n\r\n    } catch (error) {\r\n      logger.error('Incremental backup failed', { error: error.message });\r\n      return { success: false, error: error.message };\r\n    }\r\n  }\r\n\r\n  async createAutoBackup() {\r\n    return await this.createFullBackup(`auto_${Date.now()}`);\r\n  }\r\n\r\n  createEmergencyBackup() {\r\n    // Synchronous emergency backup using basic localStorage\r\n    try {\r\n      const emergencyData = {\r\n        timestamp: Date.now(),\r\n        localStorage: { ...localStorage },\r\n        sessionStorage: { ...sessionStorage }\r\n      };\r\n\r\n      localStorage.setItem('emergencyBackup', JSON.stringify(emergencyData));\r\n      logger.info('Emergency backup created');\r\n    } catch (error) {\r\n      console.error('Emergency backup failed:', error);\r\n    }\r\n  }\r\n\r\n  async scheduleIncrementalBackup(changedKey) {\r\n    // Debounce multiple rapid changes\r\n    if (this.incrementalTimeout) {\r\n      clearTimeout(this.incrementalTimeout);\r\n    }\r\n\r\n    if (!this.changedKeys) {\r\n      this.changedKeys = new Set();\r\n    }\r\n\r\n    this.changedKeys.add(changedKey);\r\n\r\n    this.incrementalTimeout = setTimeout(async () => {\r\n      const keys = Array.from(this.changedKeys);\r\n      this.changedKeys.clear();\r\n      await this.createIncrementalBackup(keys);\r\n    }, 30000); // 30 second delay\r\n  }\r\n\r\n  async restoreFromBackup(backupId, options = {}) {\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      const {\r\n        dryRun = false,\r\n        skipConfirmation = false,\r\n        selectiveRestore = null\r\n      } = options;\r\n\r\n      logger.info('Starting restore operation', { backupId, dryRun });\r\n\r\n      if (!skipConfirmation && !dryRun) {\r\n        const confirmed = window.confirm(\r\n          `Are you sure you want to restore from backup \"${backupId}\"? This will overwrite current data.`\r\n        );\r\n        if (!confirmed) {\r\n          return { success: false, cancelled: true };\r\n        }\r\n      }\r\n\r\n      // Retrieve backup\r\n      const backupKey = `${this.backupPrefix}${backupId}`;\r\n      const encryptedBackup = await this.retrieveBackup(backupKey);\r\n\r\n      if (!encryptedBackup) {\r\n        throw new Error(`Backup \"${backupId}\" not found`);\r\n      }\r\n\r\n      // Decrypt backup\r\n      const backupData = this.encryptionEnabled ?\r\n        securityManager.decryptSensitiveData(encryptedBackup) : encryptedBackup;\r\n\r\n      // Validate backup integrity\r\n      const isValid = await this.validateBackupIntegrity(backupData);\r\n      if (!isValid) {\r\n        throw new Error('Backup integrity validation failed');\r\n      }\r\n\r\n      if (dryRun) {\r\n        return {\r\n          success: true,\r\n          dryRun: true,\r\n          metadata: backupData.metadata,\r\n          dataKeys: Object.keys(backupData).filter(key => key !== 'metadata')\r\n        };\r\n      }\r\n\r\n      // Create pre-restore backup\r\n      await this.createFullBackup(`pre_restore_${Date.now()}`);\r\n\r\n      // Perform restoration\r\n      await this.performRestore(backupData, selectiveRestore);\r\n\r\n      const duration = performance.now() - startTime;\r\n      logger.info('Restore completed successfully', {\r\n        backupId,\r\n        duration: Math.round(duration)\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        backupId,\r\n        restoredAt: new Date().toISOString(),\r\n        duration\r\n      };\r\n\r\n    } catch (error) {\r\n      const duration = performance.now() - startTime;\r\n      logger.error('Restore operation failed', {\r\n        backupId,\r\n        error: error.message,\r\n        duration: Math.round(duration)\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        error: error.message,\r\n        duration\r\n      };\r\n    }\r\n  }\r\n\r\n  async performRestore(backupData, selectiveRestore) {\r\n    const { metadata, localStorage: lsData, sessionStorage: ssData, indexedDB, cache } = backupData;\r\n\r\n    // Restore localStorage\r\n    if ((!selectiveRestore || selectiveRestore.includes('localStorage')) && lsData) {\r\n      Object.entries(lsData).forEach(([key, value]) => {\r\n        if (value !== null) {\r\n          localStorage.setItem(key, value);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Restore sessionStorage\r\n    if ((!selectiveRestore || selectiveRestore.includes('sessionStorage')) && ssData) {\r\n      Object.entries(ssData).forEach(([key, value]) => {\r\n        if (value !== null) {\r\n          sessionStorage.setItem(key, value);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Restore IndexedDB\r\n    if ((!selectiveRestore || selectiveRestore.includes('indexedDB')) && indexedDB) {\r\n      await this.restoreIndexedDB(indexedDB);\r\n    }\r\n\r\n    // Restore cache\r\n    if ((!selectiveRestore || selectiveRestore.includes('cache')) && cache) {\r\n      await this.restoreCache(cache);\r\n    }\r\n\r\n    logger.info('Data restoration completed', {\r\n      restoredSections: selectiveRestore || ['all']\r\n    });\r\n  }\r\n\r\n  async backupLocalStorage() {\r\n    const data = {};\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      data[key] = localStorage.getItem(key);\r\n    }\r\n    return data;\r\n  }\r\n\r\n  async backupSessionStorage() {\r\n    const data = {};\r\n    for (let i = 0; i < sessionStorage.length; i++) {\r\n      const key = sessionStorage.key(i);\r\n      data[key] = sessionStorage.getItem(key);\r\n    }\r\n    return data;\r\n  }\r\n\r\n  async backupIndexedDB() {\r\n    try {\r\n      // Backup cache database\r\n      const cacheKeys = await cacheManager.keys('*');\r\n      const cacheData = {};\r\n\r\n      for (const key of cacheKeys) {\r\n        cacheData[key] = await cacheManager.get(key);\r\n      }\r\n\r\n      return cacheData;\r\n    } catch (error) {\r\n      logger.warn('IndexedDB backup failed', { error: error.message });\r\n      return {};\r\n    }\r\n  }\r\n\r\n  async backupCacheData() {\r\n    try {\r\n      return await cacheManager.getStats();\r\n    } catch (error) {\r\n      logger.warn('Cache backup failed', { error: error.message });\r\n      return {};\r\n    }\r\n  }\r\n\r\n  async backupUserSettings() {\r\n    return {\r\n      theme: localStorage.getItem('theme'),\r\n      language: localStorage.getItem('language'),\r\n      preferences: localStorage.getItem('userPreferences'),\r\n      settings: localStorage.getItem('appSettings')\r\n    };\r\n  }\r\n\r\n  async backupCalculations() {\r\n    try {\r\n      const calculationKeys = await cacheManager.keys('calculation:*');\r\n      const calculations = {};\r\n\r\n      for (const key of calculationKeys) {\r\n        calculations[key] = await cacheManager.get(key);\r\n      }\r\n\r\n      return calculations;\r\n    } catch (error) {\r\n      logger.warn('Calculations backup failed', { error: error.message });\r\n      return {};\r\n    }\r\n  }\r\n\r\n  async restoreIndexedDB(indexedDBData) {\r\n    try {\r\n      for (const [key, value] of Object.entries(indexedDBData)) {\r\n        await cacheManager.set(key, value, { ttl: 24 * 60 * 60 * 1000 });\r\n      }\r\n    } catch (error) {\r\n      logger.error('IndexedDB restore failed', { error: error.message });\r\n    }\r\n  }\r\n\r\n  async restoreCache(cacheData) {\r\n    try {\r\n      // Cache stats are informational only, no restoration needed\r\n      logger.info('Cache stats from backup', cacheData);\r\n    } catch (error) {\r\n      logger.error('Cache restore failed', { error: error.message });\r\n    }\r\n  }\r\n\r\n  shouldCompress(data) {\r\n    return data.length > this.compressionThreshold;\r\n  }\r\n\r\n  compressData(data) {\r\n    try {\r\n      return {\r\n        compressed: true,\r\n        data: JSON.stringify(data) // Simple JSON compression\r\n      };\r\n    } catch (error) {\r\n      logger.warn('Compression failed', { error: error.message });\r\n      return data;\r\n    }\r\n  }\r\n\r\n  decompressData(compressedData) {\r\n    try {\r\n      if (compressedData.compressed) {\r\n        return JSON.parse(compressedData.data);\r\n      }\r\n      return compressedData;\r\n    } catch (error) {\r\n      logger.error('Decompression failed', { error: error.message });\r\n      return compressedData;\r\n    }\r\n  }\r\n\r\n  calculateChecksum(data) {\r\n    let hash = 0;\r\n    for (let i = 0; i < data.length; i++) {\r\n      const char = data.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash;\r\n    }\r\n    return hash.toString(16);\r\n  }\r\n\r\n  async validateBackupIntegrity(backupData) {\r\n    try {\r\n      if (!backupData.metadata) {\r\n        logger.warn('Backup missing metadata');\r\n        return false;\r\n      }\r\n\r\n      const { checksum, size } = backupData.metadata;\r\n      const currentData = JSON.stringify(backupData);\r\n\r\n      if (size && currentData.length !== size) {\r\n        logger.warn('Backup size mismatch', {\r\n          expected: size,\r\n          actual: currentData.length\r\n        });\r\n      }\r\n\r\n      if (checksum) {\r\n        const currentChecksum = this.calculateChecksum(currentData);\r\n        if (currentChecksum !== checksum) {\r\n          logger.error('Backup checksum validation failed', {\r\n            expected: checksum,\r\n            actual: currentChecksum\r\n          });\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      logger.error('Backup validation failed', { error: error.message });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async storeBackup(key, data) {\r\n    await cacheManager.set(key, data, {\r\n      ttl: 30 * 24 * 60 * 60 * 1000, // 30 days\r\n      tags: ['backup']\r\n    });\r\n  }\r\n\r\n  async retrieveBackup(key) {\r\n    return await cacheManager.get(key);\r\n  }\r\n\r\n  async updateBackupRegistry(backupId, metadata) {\r\n    try {\r\n      const registry = await cacheManager.get('backup_registry') || {};\r\n      registry[backupId] = metadata;\r\n\r\n      await cacheManager.set('backup_registry', registry, {\r\n        ttl: 30 * 24 * 60 * 60 * 1000,\r\n        tags: ['backup', 'registry']\r\n      });\r\n    } catch (error) {\r\n      logger.error('Failed to update backup registry', { error: error.message });\r\n    }\r\n  }\r\n\r\n  async getBackupList() {\r\n    try {\r\n      const registry = await cacheManager.get('backup_registry') || {};\r\n      return Object.entries(registry)\r\n        .map(([id, metadata]) => ({ id, ...metadata }))\r\n        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));\r\n    } catch (error) {\r\n      logger.error('Failed to get backup list', { error: error.message });\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async deleteBackup(backupId) {\r\n    try {\r\n      const backupKey = `${this.backupPrefix}${backupId}`;\r\n      await cacheManager.delete(backupKey);\r\n\r\n      const registry = await cacheManager.get('backup_registry') || {};\r\n      delete registry[backupId];\r\n      await cacheManager.set('backup_registry', registry);\r\n\r\n      logger.info('Backup deleted', { backupId });\r\n      return { success: true };\r\n    } catch (error) {\r\n      logger.error('Failed to delete backup', { backupId, error: error.message });\r\n      return { success: false, error: error.message };\r\n    }\r\n  }\r\n\r\n  async cleanupOldBackups() {\r\n    try {\r\n      const backups = await this.getBackupList();\r\n      const backupsToDelete = backups.slice(this.maxBackups);\r\n\r\n      for (const backup of backupsToDelete) {\r\n        await this.deleteBackup(backup.id);\r\n      }\r\n\r\n      logger.info('Backup cleanup completed', {\r\n        totalBackups: backups.length,\r\n        deletedBackups: backupsToDelete.length,\r\n        remainingBackups: Math.min(backups.length, this.maxBackups)\r\n      });\r\n\r\n      return backupsToDelete.length;\r\n    } catch (error) {\r\n      logger.error('Backup cleanup failed', { error: error.message });\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  async getSystemHealth() {\r\n    try {\r\n      const backups = await this.getBackupList();\r\n      const lastBackup = backups[0];\r\n      const backupStats = await cacheManager.getStats();\r\n\r\n      return {\r\n        totalBackups: backups.length,\r\n        lastBackup: lastBackup ? {\r\n          id: lastBackup.id,\r\n          timestamp: lastBackup.timestamp,\r\n          type: lastBackup.type,\r\n          size: lastBackup.size\r\n        } : null,\r\n        autoBackupEnabled: !!this.autoBackupInterval,\r\n        nextAutoBackup: this.getNextBackupTime(),\r\n        storageHealth: backupStats,\r\n        encryptionEnabled: this.encryptionEnabled\r\n      };\r\n    } catch (error) {\r\n      logger.error('Failed to get system health', { error: error.message });\r\n      return { error: error.message };\r\n    }\r\n  }\r\n\r\n  getNextBackupTime() {\r\n    // Calculate next auto backup time\r\n    const now = Date.now();\r\n    const lastAutoBackupTime = this.lastAutoBackupTime || now;\r\n    return new Date(lastAutoBackupTime + this.autoBackupInterval).toISOString();\r\n  }\r\n\r\n  destroy() {\r\n    if (this.incrementalTimeout) {\r\n      clearTimeout(this.incrementalTimeout);\r\n    }\r\n    logger.info('Backup and Recovery System destroyed');\r\n  }\r\n}\r\n\r\nconst backupRecoverySystem = new BackupRecoverySystem();\r\n\r\nexport default backupRecoverySystem;\r\nexport { BackupRecoverySystem };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}