{"ast":null,"code":"import logger from './enterpriseLogger';\nimport cacheManager from './advancedCache';\nimport notificationSystem from './notificationSystem';\nclass EnterpriseMonitoringSystem {\n  constructor() {\n    this.metrics = new Map();\n    this.alerts = new Map();\n    this.thresholds = {\n      responseTime: 5000,\n      // 5 seconds\n      errorRate: 0.05,\n      // 5%\n      memoryUsage: 0.8,\n      // 80%\n      cacheHitRate: 0.7,\n      // 70%\n      apiFailureRate: 0.1,\n      // 10%\n      calculationSuccessRate: 0.95,\n      // 95%\n      systemLoad: 0.8 // 80%\n    };\n    this.monitoring = {\n      enabled: true,\n      interval: 30000,\n      // 30 seconds\n      batchSize: 100,\n      retentionPeriod: 7 * 24 * 60 * 60 * 1000 // 7 days\n    };\n    this.alertChannels = ['ui', 'console', 'storage'];\n    this.healthChecks = [];\n    this.initializeMonitoring();\n  }\n  initializeMonitoring() {\n    this.setupPerformanceObserver();\n    this.setupResourceMonitoring();\n    this.setupErrorTracking();\n    this.setupHealthChecks();\n    this.startMonitoringLoop();\n    logger.info('Enterprise Monitoring System initialized', {\n      thresholds: this.thresholds,\n      monitoring: this.monitoring\n    });\n  }\n  setupPerformanceObserver() {\n    if ('PerformanceObserver' in window) {\n      try {\n        const observer = new PerformanceObserver(list => {\n          const entries = list.getEntries();\n          entries.forEach(entry => this.recordPerformanceMetric(entry));\n        });\n        observer.observe({\n          entryTypes: ['navigation', 'measure', 'resource']\n        });\n        this.performanceObserver = observer;\n      } catch (error) {\n        logger.warn('Performance Observer setup failed', {\n          error: error.message\n        });\n      }\n    }\n  }\n  setupResourceMonitoring() {\n    // Monitor memory usage\n    setInterval(() => {\n      if ('memory' in performance) {\n        this.recordMetric('memory.used', performance.memory.usedJSHeapSize);\n        this.recordMetric('memory.total', performance.memory.totalJSHeapSize);\n        this.recordMetric('memory.limit', performance.memory.jsHeapSizeLimit);\n        const usage = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;\n        this.checkThreshold('memoryUsage', usage);\n      }\n    }, this.monitoring.interval);\n\n    // Monitor connection status\n    this.monitorNetworkStatus();\n  }\n  setupErrorTracking() {\n    // Global error handler\n    window.addEventListener('error', event => {\n      var _event$error;\n      this.recordError('javascript', {\n        message: event.message,\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        stack: (_event$error = event.error) === null || _event$error === void 0 ? void 0 : _event$error.stack\n      });\n    });\n\n    // Promise rejection handler\n    window.addEventListener('unhandledrejection', event => {\n      this.recordError('promise', {\n        reason: event.reason,\n        promise: event.promise\n      });\n    });\n  }\n  setupHealthChecks() {\n    // System health checks\n    this.addHealthCheck('cache', async () => {\n      try {\n        const stats = await cacheManager.getStats();\n        return {\n          status: 'healthy',\n          metrics: stats,\n          hitRate: stats.hitRate || 0\n        };\n      } catch (error) {\n        return {\n          status: 'unhealthy',\n          error: error.message\n        };\n      }\n    });\n    this.addHealthCheck('storage', async () => {\n      try {\n        const testKey = 'health_check_' + Date.now();\n        localStorage.setItem(testKey, 'test');\n        const value = localStorage.getItem(testKey);\n        localStorage.removeItem(testKey);\n        return {\n          status: value === 'test' ? 'healthy' : 'degraded',\n          metrics: {\n            localStorageAvailable: true,\n            itemCount: localStorage.length\n          }\n        };\n      } catch (error) {\n        return {\n          status: 'unhealthy',\n          error: error.message\n        };\n      }\n    });\n    this.addHealthCheck('network', async () => {\n      try {\n        const start = performance.now();\n        const response = await fetch('https://httpbin.org/status/200', {\n          method: 'HEAD',\n          cache: 'no-cache'\n        });\n        const duration = performance.now() - start;\n        return {\n          status: response.ok ? 'healthy' : 'degraded',\n          metrics: {\n            responseTime: Math.round(duration),\n            status: response.status\n          }\n        };\n      } catch (error) {\n        return {\n          status: 'unhealthy',\n          error: error.message\n        };\n      }\n    });\n    this.addHealthCheck('api', async () => {\n      try {\n        // Test basic API connectivity (simplified)\n        const testData = {\n          action: 'test',\n          timestamp: Date.now()\n        };\n        const response = await fetch('/api/test', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify(testData)\n        });\n        return {\n          status: response.ok ? 'healthy' : 'degraded',\n          metrics: {\n            status: response.status,\n            available: response.ok\n          }\n        };\n      } catch (error) {\n        return {\n          status: 'degraded',\n          error: 'API not available or CORS issue'\n        };\n      }\n    });\n  }\n  startMonitoringLoop() {\n    setInterval(async () => {\n      if (this.monitoring.enabled) {\n        await this.collectSystemMetrics();\n        await this.runHealthChecks();\n        await this.processAlerts();\n        await this.cleanupOldMetrics();\n      }\n    }, this.monitoring.interval);\n\n    // Initial run after 5 seconds\n    setTimeout(() => this.collectSystemMetrics(), 5000);\n  }\n  async collectSystemMetrics() {\n    try {\n      const metrics = {\n        timestamp: Date.now(),\n        system: await this.getSystemMetrics(),\n        performance: await this.getPerformanceMetrics(),\n        cache: await this.getCacheMetrics(),\n        errors: await this.getErrorMetrics()\n      };\n      await this.storeMetrics(metrics);\n      this.analyzeMetrics(metrics);\n    } catch (error) {\n      logger.error('Failed to collect system metrics', {\n        error: error.message\n      });\n    }\n  }\n  async getSystemMetrics() {\n    return {\n      timestamp: Date.now(),\n      userAgent: navigator.userAgent,\n      online: navigator.onLine,\n      cookieEnabled: navigator.cookieEnabled,\n      language: navigator.language,\n      platform: navigator.platform,\n      viewport: {\n        width: window.innerWidth,\n        height: window.innerHeight\n      },\n      memory: 'memory' in performance ? {\n        used: performance.memory.usedJSHeapSize,\n        total: performance.memory.totalJSHeapSize,\n        limit: performance.memory.jsHeapSizeLimit,\n        usage: performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit\n      } : null\n    };\n  }\n  async getPerformanceMetrics() {\n    const navigation = performance.getEntriesByType('navigation')[0];\n    return {\n      domContentLoaded: (navigation === null || navigation === void 0 ? void 0 : navigation.domContentLoadedEventEnd) - (navigation === null || navigation === void 0 ? void 0 : navigation.domContentLoadedEventStart) || 0,\n      loadComplete: (navigation === null || navigation === void 0 ? void 0 : navigation.loadEventEnd) - (navigation === null || navigation === void 0 ? void 0 : navigation.loadEventStart) || 0,\n      firstPaint: this.getFirstPaint(),\n      firstContentfulPaint: this.getFirstContentfulPaint(),\n      timeToInteractive: this.estimateTimeToInteractive()\n    };\n  }\n  async getCacheMetrics() {\n    try {\n      const stats = await cacheManager.getStats();\n      const cacheMetrics = await cacheManager.getMetrics();\n      return {\n        ...stats,\n        operations: cacheMetrics\n      };\n    } catch (error) {\n      logger.warn('Failed to get cache metrics', {\n        error: error.message\n      });\n      return {};\n    }\n  }\n  async getErrorMetrics() {\n    const errors = this.metrics.get('errors') || [];\n    const recentErrors = errors.filter(error => Date.now() - error.timestamp < this.monitoring.interval * 2);\n    return {\n      totalErrors: errors.length,\n      recentErrors: recentErrors.length,\n      errorRate: recentErrors.length / this.monitoring.interval * 1000,\n      // errors per second\n      errorTypes: this.categorizeErrors(recentErrors)\n    };\n  }\n  getFirstPaint() {\n    const paintEntries = performance.getEntriesByType('paint');\n    const firstPaint = paintEntries.find(entry => entry.name === 'first-paint');\n    return firstPaint ? Math.round(firstPaint.startTime) : 0;\n  }\n  getFirstContentfulPaint() {\n    const paintEntries = performance.getEntriesByType('paint');\n    const fcp = paintEntries.find(entry => entry.name === 'first-contentful-paint');\n    return fcp ? Math.round(fcp.startTime) : 0;\n  }\n  estimateTimeToInteractive() {\n    // Simplified TTI estimation\n    const navigation = performance.getEntriesByType('navigation')[0];\n    return navigation ? Math.round(navigation.domInteractive - navigation.fetchStart) : 0;\n  }\n  recordMetric(name, value, metadata = {}) {\n    const metric = {\n      name,\n      value,\n      timestamp: Date.now(),\n      metadata\n    };\n    if (!this.metrics.has(name)) {\n      this.metrics.set(name, []);\n    }\n    const metrics = this.metrics.get(name);\n    metrics.push(metric);\n\n    // Keep only recent metrics\n    const cutoff = Date.now() - this.monitoring.retentionPeriod;\n    this.metrics.set(name, metrics.filter(m => m.timestamp > cutoff));\n\n    // Check thresholds\n    this.checkThreshold(name, value);\n  }\n  recordPerformanceMetric(entry) {\n    const metric = {\n      name: entry.name,\n      type: entry.entryType,\n      startTime: entry.startTime,\n      duration: entry.duration,\n      timestamp: Date.now()\n    };\n    this.recordMetric(`performance.${entry.entryType}`, entry.duration, metric);\n\n    // Check performance thresholds\n    if (entry.entryType === 'navigation' || entry.entryType === 'measure') {\n      this.checkThreshold('responseTime', entry.duration);\n    }\n  }\n  recordError(type, details) {\n    const error = {\n      type,\n      details,\n      timestamp: Date.now(),\n      url: window.location.href,\n      userAgent: navigator.userAgent\n    };\n    if (!this.metrics.has('errors')) {\n      this.metrics.set('errors', []);\n    }\n    this.metrics.get('errors').push(error);\n\n    // Trigger immediate alert for critical errors\n    this.triggerAlert('error', 'critical', `${type} error occurred`, error);\n    logger.error(`Monitoring: ${type} error recorded`, details);\n  }\n  checkThreshold(metricName, value) {\n    const threshold = this.thresholds[metricName];\n    if (!threshold) return;\n    const exceeded = value > threshold;\n    if (exceeded) {\n      this.triggerAlert('threshold', 'warning', `${metricName} threshold exceeded`, {\n        metric: metricName,\n        value,\n        threshold\n      });\n    }\n  }\n  triggerAlert(type, severity, message, data = {}) {\n    const alert = {\n      id: this.generateAlertId(),\n      type,\n      severity,\n      message,\n      data,\n      timestamp: Date.now(),\n      resolved: false\n    };\n    this.alerts.set(alert.id, alert);\n\n    // Send notifications based on severity\n    this.sendAlert(alert);\n    logger.warn(`Alert triggered: ${message}`, alert);\n  }\n  async sendAlert(alert) {\n    try {\n      // Send to configured channels\n      for (const channel of this.alertChannels) {\n        switch (channel) {\n          case 'ui':\n            await notificationSystem.error(alert.message, {\n              priority: alert.severity === 'critical' ? 'high' : 'medium',\n              category: 'monitoring',\n              metadata: alert.data\n            });\n            break;\n          case 'console':\n            console.warn('ðŸš¨ MONITORING ALERT:', alert);\n            break;\n          case 'storage':\n            await this.storeAlert(alert);\n            break;\n          case 'webhook':\n            await this.sendWebhookAlert(alert);\n            break;\n        }\n      }\n    } catch (error) {\n      logger.error('Failed to send alert', {\n        alertId: alert.id,\n        error: error.message\n      });\n    }\n  }\n  async runHealthChecks() {\n    const results = {};\n    for (const [name, checkFn] of this.healthChecks) {\n      try {\n        const result = await checkFn();\n        results[name] = result;\n\n        // Trigger alerts for unhealthy systems\n        if (result.status === 'unhealthy') {\n          this.triggerAlert('health', 'critical', `Health check failed: ${name}`, result);\n        }\n      } catch (error) {\n        results[name] = {\n          status: 'error',\n          error: error.message\n        };\n        this.triggerAlert('health', 'critical', `Health check error: ${name}`, {\n          error: error.message\n        });\n      }\n    }\n    await this.storeHealthCheckResults(results);\n    return results;\n  }\n  addHealthCheck(name, checkFunction) {\n    this.healthChecks.push([name, checkFunction]);\n  }\n  removeHealthCheck(name) {\n    this.healthChecks = this.healthChecks.filter(([checkName]) => checkName !== name);\n  }\n  async processAlerts() {\n    const now = Date.now();\n    const autoResolveTime = 5 * 60 * 1000; // 5 minutes\n\n    // Auto-resolve old alerts\n    for (const [id, alert] of this.alerts.entries()) {\n      if (!alert.resolved && now - alert.timestamp > autoResolveTime) {\n        await this.resolveAlert(id);\n      }\n    }\n\n    // Clean up old resolved alerts\n    const oldAlerts = Array.from(this.alerts.entries()).filter(([, alert]) => alert.resolved && now - alert.timestamp > 24 * 60 * 60 * 1000);\n    oldAlerts.forEach(([id]) => this.alerts.delete(id));\n  }\n  async resolveAlert(alertId) {\n    const alert = this.alerts.get(alertId);\n    if (alert) {\n      alert.resolved = true;\n      alert.resolvedAt = Date.now();\n      logger.info('Alert resolved', {\n        alertId,\n        alert: alert.message\n      });\n    }\n  }\n  categorizeErrors(errors) {\n    const categories = {};\n    errors.forEach(error => {\n      const category = error.type || 'unknown';\n      categories[category] = (categories[category] || 0) + 1;\n    });\n    return categories;\n  }\n  analyzeMetrics(metrics) {\n    var _metrics$performance, _metrics$errors, _metrics$cache;\n    // Analyze trends and patterns\n    const analysis = {\n      timestamp: metrics.timestamp,\n      performance: this.analyzePerformance(metrics.performance),\n      errors: this.analyzeErrors(metrics.errors),\n      cache: this.analyzeCachePerformance(metrics.cache),\n      recommendations: []\n    };\n\n    // Generate recommendations\n    if (((_metrics$performance = metrics.performance) === null || _metrics$performance === void 0 ? void 0 : _metrics$performance.domContentLoaded) > 3000) {\n      analysis.recommendations.push({\n        type: 'performance',\n        priority: 'medium',\n        message: 'DOM Content Loaded time is high. Consider optimizing JavaScript loading.'\n      });\n    }\n    if (((_metrics$errors = metrics.errors) === null || _metrics$errors === void 0 ? void 0 : _metrics$errors.errorRate) > this.thresholds.errorRate) {\n      analysis.recommendations.push({\n        type: 'reliability',\n        priority: 'high',\n        message: 'Error rate is above threshold. Investigate recent errors.'\n      });\n    }\n    if (((_metrics$cache = metrics.cache) === null || _metrics$cache === void 0 ? void 0 : _metrics$cache.hitRate) < this.thresholds.cacheHitRate) {\n      analysis.recommendations.push({\n        type: 'performance',\n        priority: 'medium',\n        message: 'Cache hit rate is low. Review caching strategy.'\n      });\n    }\n    return analysis;\n  }\n  analyzePerformance(performanceMetrics) {\n    if (!performanceMetrics) return null;\n    return {\n      score: this.calculatePerformanceScore(performanceMetrics),\n      bottlenecks: this.identifyBottlenecks(performanceMetrics),\n      trends: this.getPerformanceTrends()\n    };\n  }\n  calculatePerformanceScore(metrics) {\n    let score = 100;\n\n    // Deduct points for slow metrics\n    if (metrics.domContentLoaded > 2000) score -= 20;\n    if (metrics.loadComplete > 4000) score -= 20;\n    if (metrics.firstContentfulPaint > 1500) score -= 15;\n    if (metrics.timeToInteractive > 3000) score -= 25;\n    return Math.max(0, score);\n  }\n  identifyBottlenecks(metrics) {\n    const bottlenecks = [];\n    if (metrics.domContentLoaded > 3000) {\n      bottlenecks.push('Slow DOM content loading');\n    }\n    if (metrics.firstContentfulPaint > 2000) {\n      bottlenecks.push('Slow first paint');\n    }\n    if (metrics.timeToInteractive > 5000) {\n      bottlenecks.push('Slow time to interactive');\n    }\n    return bottlenecks;\n  }\n  getPerformanceTrends() {\n    // Simple trend analysis\n    const recentMetrics = this.metrics.get('performance.navigation') || [];\n    const last5 = recentMetrics.slice(-5);\n    if (last5.length < 2) return 'insufficient_data';\n    const trend = last5[last5.length - 1].value - last5[0].value;\n    return trend > 0 ? 'degrading' : 'improving';\n  }\n  analyzeErrors(errorMetrics) {\n    if (!errorMetrics) return null;\n    return {\n      severity: this.categorizeErrorSeverity(errorMetrics),\n      patterns: this.identifyErrorPatterns(errorMetrics),\n      frequency: errorMetrics.errorRate\n    };\n  }\n  categorizeErrorSeverity(errorMetrics) {\n    if (errorMetrics.errorRate > 0.1) return 'critical';\n    if (errorMetrics.errorRate > 0.05) return 'high';\n    if (errorMetrics.errorRate > 0.01) return 'medium';\n    return 'low';\n  }\n  identifyErrorPatterns(errorMetrics) {\n    const errors = this.metrics.get('errors') || [];\n    const recentErrors = errors.slice(-10);\n    const patterns = {};\n    recentErrors.forEach(error => {\n      var _error$details;\n      const pattern = ((_error$details = error.details) === null || _error$details === void 0 ? void 0 : _error$details.message) || error.type;\n      patterns[pattern] = (patterns[pattern] || 0) + 1;\n    });\n    return patterns;\n  }\n  analyzeCachePerformance(cacheMetrics) {\n    if (!cacheMetrics) return null;\n    return {\n      efficiency: cacheMetrics.hitRate || 0,\n      utilization: this.calculateCacheUtilization(cacheMetrics),\n      recommendations: this.getCacheRecommendations(cacheMetrics)\n    };\n  }\n  calculateCacheUtilization(metrics) {\n    if (!metrics.memorySize || !metrics.maxMemorySize) return 0;\n    return metrics.memorySize / metrics.maxMemorySize;\n  }\n  getCacheRecommendations(metrics) {\n    const recommendations = [];\n    if (metrics.hitRate < 0.7) {\n      recommendations.push('Consider adjusting cache TTL values');\n    }\n    if (metrics.evictions > metrics.sets * 0.1) {\n      recommendations.push('Cache size may be too small');\n    }\n    return recommendations;\n  }\n  monitorNetworkStatus() {\n    window.addEventListener('online', () => {\n      this.recordMetric('network.status', 1, {\n        status: 'online'\n      });\n      logger.info('Network status: online');\n    });\n    window.addEventListener('offline', () => {\n      this.recordMetric('network.status', 0, {\n        status: 'offline'\n      });\n      this.triggerAlert('network', 'warning', 'Network connection lost', {});\n      logger.warn('Network status: offline');\n    });\n  }\n  async storeMetrics(metrics) {\n    try {\n      const key = `metrics:${Date.now()}`;\n      await cacheManager.set(key, metrics, {\n        ttl: this.monitoring.retentionPeriod,\n        tags: ['metrics']\n      });\n    } catch (error) {\n      logger.error('Failed to store metrics', {\n        error: error.message\n      });\n    }\n  }\n  async storeAlert(alert) {\n    try {\n      const key = `alert:${alert.id}`;\n      await cacheManager.set(key, alert, {\n        ttl: 7 * 24 * 60 * 60 * 1000,\n        // 7 days\n        tags: ['alerts']\n      });\n    } catch (error) {\n      logger.error('Failed to store alert', {\n        error: error.message\n      });\n    }\n  }\n  async storeHealthCheckResults(results) {\n    try {\n      const key = `health:${Date.now()}`;\n      await cacheManager.set(key, results, {\n        ttl: 24 * 60 * 60 * 1000,\n        // 24 hours\n        tags: ['health']\n      });\n    } catch (error) {\n      logger.error('Failed to store health check results', {\n        error: error.message\n      });\n    }\n  }\n  async sendWebhookAlert(alert) {\n    // Placeholder for webhook integration\n    logger.info('Webhook alert would be sent', alert);\n  }\n  generateAlertId() {\n    return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n  async cleanupOldMetrics() {\n    try {\n      const cutoff = Date.now() - this.monitoring.retentionPeriod;\n\n      // Clean up in-memory metrics\n      for (const [name, metrics] of this.metrics.entries()) {\n        const filtered = metrics.filter(m => m.timestamp > cutoff);\n        this.metrics.set(name, filtered);\n      }\n\n      // Clean up cached metrics\n      await cacheManager.deleteByTags(['metrics']);\n      logger.debug('Old metrics cleaned up', {\n        cutoff: new Date(cutoff)\n      });\n    } catch (error) {\n      logger.error('Failed to cleanup old metrics', {\n        error: error.message\n      });\n    }\n  }\n  async getSystemReport() {\n    try {\n      const healthChecks = await this.runHealthChecks();\n      const recentMetrics = await this.getRecentMetrics();\n      const activeAlerts = Array.from(this.alerts.values()).filter(alert => !alert.resolved);\n      return {\n        timestamp: Date.now(),\n        systemHealth: this.calculateOverallHealth(healthChecks),\n        healthChecks,\n        metrics: recentMetrics,\n        alerts: {\n          active: activeAlerts.length,\n          critical: activeAlerts.filter(a => a.severity === 'critical').length,\n          warnings: activeAlerts.filter(a => a.severity === 'warning').length\n        },\n        performance: await this.getPerformanceSummary(),\n        recommendations: this.getSystemRecommendations(healthChecks, recentMetrics)\n      };\n    } catch (error) {\n      logger.error('Failed to generate system report', {\n        error: error.message\n      });\n      return {\n        error: error.message\n      };\n    }\n  }\n  calculateOverallHealth(healthChecks) {\n    const statuses = Object.values(healthChecks).map(check => check.status);\n    const healthy = statuses.filter(status => status === 'healthy').length;\n    const total = statuses.length;\n    if (statuses.includes('unhealthy')) return 'critical';\n    if (statuses.includes('degraded')) return 'degraded';\n    if (healthy === total) return 'healthy';\n    return 'unknown';\n  }\n  async getRecentMetrics() {\n    const recent = {};\n    for (const [name, metrics] of this.metrics.entries()) {\n      const recentMetrics = metrics.slice(-5);\n      if (recentMetrics.length > 0) {\n        recent[name] = {\n          latest: recentMetrics[recentMetrics.length - 1],\n          count: recentMetrics.length,\n          average: recentMetrics.reduce((sum, m) => sum + m.value, 0) / recentMetrics.length\n        };\n      }\n    }\n    return recent;\n  }\n  async getPerformanceSummary() {\n    const navigation = performance.getEntriesByType('navigation')[0];\n    if (!navigation) return null;\n    return {\n      pageLoad: Math.round(navigation.loadEventEnd - navigation.fetchStart),\n      domReady: Math.round(navigation.domContentLoadedEventEnd - navigation.fetchStart),\n      firstPaint: this.getFirstPaint(),\n      score: this.calculatePerformanceScore({\n        domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,\n        loadComplete: navigation.loadEventEnd - navigation.loadEventStart,\n        firstContentfulPaint: this.getFirstContentfulPaint(),\n        timeToInteractive: navigation.domInteractive - navigation.fetchStart\n      })\n    };\n  }\n  getSystemRecommendations(healthChecks, metrics) {\n    var _metrics$memoryUsage, _metrics$memoryUsage$;\n    const recommendations = [];\n\n    // Health-based recommendations\n    Object.entries(healthChecks).forEach(([name, check]) => {\n      if (check.status === 'unhealthy') {\n        recommendations.push({\n          type: 'critical',\n          component: name,\n          message: `${name} is unhealthy and requires immediate attention`\n        });\n      }\n    });\n\n    // Metric-based recommendations\n    if (((_metrics$memoryUsage = metrics['memory.usage']) === null || _metrics$memoryUsage === void 0 ? void 0 : (_metrics$memoryUsage$ = _metrics$memoryUsage.latest) === null || _metrics$memoryUsage$ === void 0 ? void 0 : _metrics$memoryUsage$.value) > 0.8) {\n      recommendations.push({\n        type: 'warning',\n        component: 'memory',\n        message: 'Memory usage is high. Consider clearing caches or reducing data retention.'\n      });\n    }\n    return recommendations;\n  }\n  setThreshold(metric, value) {\n    this.thresholds[metric] = value;\n    logger.info('Threshold updated', {\n      metric,\n      value\n    });\n  }\n  setMonitoringEnabled(enabled) {\n    this.monitoring.enabled = enabled;\n    logger.info(`Monitoring ${enabled ? 'enabled' : 'disabled'}`);\n  }\n  addAlertChannel(channel) {\n    if (!this.alertChannels.includes(channel)) {\n      this.alertChannels.push(channel);\n      logger.info('Alert channel added', {\n        channel\n      });\n    }\n  }\n  removeAlertChannel(channel) {\n    this.alertChannels = this.alertChannels.filter(c => c !== channel);\n    logger.info('Alert channel removed', {\n      channel\n    });\n  }\n  destroy() {\n    if (this.performanceObserver) {\n      this.performanceObserver.disconnect();\n    }\n    this.monitoring.enabled = false;\n    logger.info('Enterprise Monitoring System destroyed');\n  }\n}\nconst enterpriseMonitoring = new EnterpriseMonitoringSystem();\nexport default enterpriseMonitoring;\nexport { EnterpriseMonitoringSystem };","map":{"version":3,"names":["logger","cacheManager","notificationSystem","EnterpriseMonitoringSystem","constructor","metrics","Map","alerts","thresholds","responseTime","errorRate","memoryUsage","cacheHitRate","apiFailureRate","calculationSuccessRate","systemLoad","monitoring","enabled","interval","batchSize","retentionPeriod","alertChannels","healthChecks","initializeMonitoring","setupPerformanceObserver","setupResourceMonitoring","setupErrorTracking","setupHealthChecks","startMonitoringLoop","info","window","observer","PerformanceObserver","list","entries","getEntries","forEach","entry","recordPerformanceMetric","observe","entryTypes","performanceObserver","error","warn","message","setInterval","performance","recordMetric","memory","usedJSHeapSize","totalJSHeapSize","jsHeapSizeLimit","usage","checkThreshold","monitorNetworkStatus","addEventListener","event","_event$error","recordError","filename","lineno","colno","stack","reason","promise","addHealthCheck","stats","getStats","status","hitRate","testKey","Date","now","localStorage","setItem","value","getItem","removeItem","localStorageAvailable","itemCount","length","start","response","fetch","method","cache","duration","ok","Math","round","testData","action","timestamp","headers","body","JSON","stringify","available","collectSystemMetrics","runHealthChecks","processAlerts","cleanupOldMetrics","setTimeout","system","getSystemMetrics","getPerformanceMetrics","getCacheMetrics","errors","getErrorMetrics","storeMetrics","analyzeMetrics","userAgent","navigator","online","onLine","cookieEnabled","language","platform","viewport","width","innerWidth","height","innerHeight","used","total","limit","navigation","getEntriesByType","domContentLoaded","domContentLoadedEventEnd","domContentLoadedEventStart","loadComplete","loadEventEnd","loadEventStart","firstPaint","getFirstPaint","firstContentfulPaint","getFirstContentfulPaint","timeToInteractive","estimateTimeToInteractive","cacheMetrics","getMetrics","operations","get","recentErrors","filter","totalErrors","errorTypes","categorizeErrors","paintEntries","find","name","startTime","fcp","domInteractive","fetchStart","metadata","metric","has","set","push","cutoff","m","type","entryType","details","url","location","href","triggerAlert","metricName","threshold","exceeded","severity","data","alert","id","generateAlertId","resolved","sendAlert","channel","priority","category","console","storeAlert","sendWebhookAlert","alertId","results","checkFn","result","storeHealthCheckResults","checkFunction","removeHealthCheck","checkName","autoResolveTime","resolveAlert","oldAlerts","Array","from","delete","resolvedAt","categories","_metrics$performance","_metrics$errors","_metrics$cache","analysis","analyzePerformance","analyzeErrors","analyzeCachePerformance","recommendations","performanceMetrics","score","calculatePerformanceScore","bottlenecks","identifyBottlenecks","trends","getPerformanceTrends","max","recentMetrics","last5","slice","trend","errorMetrics","categorizeErrorSeverity","patterns","identifyErrorPatterns","frequency","_error$details","pattern","efficiency","utilization","calculateCacheUtilization","getCacheRecommendations","memorySize","maxMemorySize","evictions","sets","key","ttl","tags","random","toString","substr","filtered","deleteByTags","debug","getSystemReport","getRecentMetrics","activeAlerts","values","systemHealth","calculateOverallHealth","active","critical","a","warnings","getPerformanceSummary","getSystemRecommendations","statuses","Object","map","check","healthy","includes","recent","latest","count","average","reduce","sum","pageLoad","domReady","_metrics$memoryUsage","_metrics$memoryUsage$","component","setThreshold","setMonitoringEnabled","addAlertChannel","removeAlertChannel","c","destroy","disconnect","enterpriseMonitoring"],"sources":["C:/Users/PC_User/Desktop/free-crm/bhotch-crm/src/utils/enterpriseMonitoring.js"],"sourcesContent":["import logger from './enterpriseLogger';\r\nimport cacheManager from './advancedCache';\r\nimport notificationSystem from './notificationSystem';\r\n\r\nclass EnterpriseMonitoringSystem {\r\n  constructor() {\r\n    this.metrics = new Map();\r\n    this.alerts = new Map();\r\n    this.thresholds = {\r\n      responseTime: 5000,        // 5 seconds\r\n      errorRate: 0.05,           // 5%\r\n      memoryUsage: 0.8,          // 80%\r\n      cacheHitRate: 0.7,         // 70%\r\n      apiFailureRate: 0.1,       // 10%\r\n      calculationSuccessRate: 0.95, // 95%\r\n      systemLoad: 0.8            // 80%\r\n    };\r\n\r\n    this.monitoring = {\r\n      enabled: true,\r\n      interval: 30000,           // 30 seconds\r\n      batchSize: 100,\r\n      retentionPeriod: 7 * 24 * 60 * 60 * 1000 // 7 days\r\n    };\r\n\r\n    this.alertChannels = ['ui', 'console', 'storage'];\r\n    this.healthChecks = [];\r\n\r\n    this.initializeMonitoring();\r\n  }\r\n\r\n  initializeMonitoring() {\r\n    this.setupPerformanceObserver();\r\n    this.setupResourceMonitoring();\r\n    this.setupErrorTracking();\r\n    this.setupHealthChecks();\r\n    this.startMonitoringLoop();\r\n\r\n    logger.info('Enterprise Monitoring System initialized', {\r\n      thresholds: this.thresholds,\r\n      monitoring: this.monitoring\r\n    });\r\n  }\r\n\r\n  setupPerformanceObserver() {\r\n    if ('PerformanceObserver' in window) {\r\n      try {\r\n        const observer = new PerformanceObserver((list) => {\r\n          const entries = list.getEntries();\r\n          entries.forEach(entry => this.recordPerformanceMetric(entry));\r\n        });\r\n\r\n        observer.observe({ entryTypes: ['navigation', 'measure', 'resource'] });\r\n        this.performanceObserver = observer;\r\n      } catch (error) {\r\n        logger.warn('Performance Observer setup failed', { error: error.message });\r\n      }\r\n    }\r\n  }\r\n\r\n  setupResourceMonitoring() {\r\n    // Monitor memory usage\r\n    setInterval(() => {\r\n      if ('memory' in performance) {\r\n        this.recordMetric('memory.used', performance.memory.usedJSHeapSize);\r\n        this.recordMetric('memory.total', performance.memory.totalJSHeapSize);\r\n        this.recordMetric('memory.limit', performance.memory.jsHeapSizeLimit);\r\n\r\n        const usage = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;\r\n        this.checkThreshold('memoryUsage', usage);\r\n      }\r\n    }, this.monitoring.interval);\r\n\r\n    // Monitor connection status\r\n    this.monitorNetworkStatus();\r\n  }\r\n\r\n  setupErrorTracking() {\r\n    // Global error handler\r\n    window.addEventListener('error', (event) => {\r\n      this.recordError('javascript', {\r\n        message: event.message,\r\n        filename: event.filename,\r\n        lineno: event.lineno,\r\n        colno: event.colno,\r\n        stack: event.error?.stack\r\n      });\r\n    });\r\n\r\n    // Promise rejection handler\r\n    window.addEventListener('unhandledrejection', (event) => {\r\n      this.recordError('promise', {\r\n        reason: event.reason,\r\n        promise: event.promise\r\n      });\r\n    });\r\n  }\r\n\r\n  setupHealthChecks() {\r\n    // System health checks\r\n    this.addHealthCheck('cache', async () => {\r\n      try {\r\n        const stats = await cacheManager.getStats();\r\n        return {\r\n          status: 'healthy',\r\n          metrics: stats,\r\n          hitRate: stats.hitRate || 0\r\n        };\r\n      } catch (error) {\r\n        return {\r\n          status: 'unhealthy',\r\n          error: error.message\r\n        };\r\n      }\r\n    });\r\n\r\n    this.addHealthCheck('storage', async () => {\r\n      try {\r\n        const testKey = 'health_check_' + Date.now();\r\n        localStorage.setItem(testKey, 'test');\r\n        const value = localStorage.getItem(testKey);\r\n        localStorage.removeItem(testKey);\r\n\r\n        return {\r\n          status: value === 'test' ? 'healthy' : 'degraded',\r\n          metrics: {\r\n            localStorageAvailable: true,\r\n            itemCount: localStorage.length\r\n          }\r\n        };\r\n      } catch (error) {\r\n        return {\r\n          status: 'unhealthy',\r\n          error: error.message\r\n        };\r\n      }\r\n    });\r\n\r\n    this.addHealthCheck('network', async () => {\r\n      try {\r\n        const start = performance.now();\r\n        const response = await fetch('https://httpbin.org/status/200', {\r\n          method: 'HEAD',\r\n          cache: 'no-cache'\r\n        });\r\n        const duration = performance.now() - start;\r\n\r\n        return {\r\n          status: response.ok ? 'healthy' : 'degraded',\r\n          metrics: {\r\n            responseTime: Math.round(duration),\r\n            status: response.status\r\n          }\r\n        };\r\n      } catch (error) {\r\n        return {\r\n          status: 'unhealthy',\r\n          error: error.message\r\n        };\r\n      }\r\n    });\r\n\r\n    this.addHealthCheck('api', async () => {\r\n      try {\r\n        // Test basic API connectivity (simplified)\r\n        const testData = { action: 'test', timestamp: Date.now() };\r\n        const response = await fetch('/api/test', {\r\n          method: 'POST',\r\n          headers: { 'Content-Type': 'application/json' },\r\n          body: JSON.stringify(testData)\r\n        });\r\n\r\n        return {\r\n          status: response.ok ? 'healthy' : 'degraded',\r\n          metrics: {\r\n            status: response.status,\r\n            available: response.ok\r\n          }\r\n        };\r\n      } catch (error) {\r\n        return {\r\n          status: 'degraded',\r\n          error: 'API not available or CORS issue'\r\n        };\r\n      }\r\n    });\r\n  }\r\n\r\n  startMonitoringLoop() {\r\n    setInterval(async () => {\r\n      if (this.monitoring.enabled) {\r\n        await this.collectSystemMetrics();\r\n        await this.runHealthChecks();\r\n        await this.processAlerts();\r\n        await this.cleanupOldMetrics();\r\n      }\r\n    }, this.monitoring.interval);\r\n\r\n    // Initial run after 5 seconds\r\n    setTimeout(() => this.collectSystemMetrics(), 5000);\r\n  }\r\n\r\n  async collectSystemMetrics() {\r\n    try {\r\n      const metrics = {\r\n        timestamp: Date.now(),\r\n        system: await this.getSystemMetrics(),\r\n        performance: await this.getPerformanceMetrics(),\r\n        cache: await this.getCacheMetrics(),\r\n        errors: await this.getErrorMetrics()\r\n      };\r\n\r\n      await this.storeMetrics(metrics);\r\n      this.analyzeMetrics(metrics);\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to collect system metrics', { error: error.message });\r\n    }\r\n  }\r\n\r\n  async getSystemMetrics() {\r\n    return {\r\n      timestamp: Date.now(),\r\n      userAgent: navigator.userAgent,\r\n      online: navigator.onLine,\r\n      cookieEnabled: navigator.cookieEnabled,\r\n      language: navigator.language,\r\n      platform: navigator.platform,\r\n      viewport: {\r\n        width: window.innerWidth,\r\n        height: window.innerHeight\r\n      },\r\n      memory: 'memory' in performance ? {\r\n        used: performance.memory.usedJSHeapSize,\r\n        total: performance.memory.totalJSHeapSize,\r\n        limit: performance.memory.jsHeapSizeLimit,\r\n        usage: performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit\r\n      } : null\r\n    };\r\n  }\r\n\r\n  async getPerformanceMetrics() {\r\n    const navigation = performance.getEntriesByType('navigation')[0];\r\n\r\n    return {\r\n      domContentLoaded: navigation?.domContentLoadedEventEnd - navigation?.domContentLoadedEventStart || 0,\r\n      loadComplete: navigation?.loadEventEnd - navigation?.loadEventStart || 0,\r\n      firstPaint: this.getFirstPaint(),\r\n      firstContentfulPaint: this.getFirstContentfulPaint(),\r\n      timeToInteractive: this.estimateTimeToInteractive()\r\n    };\r\n  }\r\n\r\n  async getCacheMetrics() {\r\n    try {\r\n      const stats = await cacheManager.getStats();\r\n      const cacheMetrics = await cacheManager.getMetrics();\r\n\r\n      return {\r\n        ...stats,\r\n        operations: cacheMetrics\r\n      };\r\n    } catch (error) {\r\n      logger.warn('Failed to get cache metrics', { error: error.message });\r\n      return {};\r\n    }\r\n  }\r\n\r\n  async getErrorMetrics() {\r\n    const errors = this.metrics.get('errors') || [];\r\n    const recentErrors = errors.filter(\r\n      error => Date.now() - error.timestamp < this.monitoring.interval * 2\r\n    );\r\n\r\n    return {\r\n      totalErrors: errors.length,\r\n      recentErrors: recentErrors.length,\r\n      errorRate: recentErrors.length / this.monitoring.interval * 1000, // errors per second\r\n      errorTypes: this.categorizeErrors(recentErrors)\r\n    };\r\n  }\r\n\r\n  getFirstPaint() {\r\n    const paintEntries = performance.getEntriesByType('paint');\r\n    const firstPaint = paintEntries.find(entry => entry.name === 'first-paint');\r\n    return firstPaint ? Math.round(firstPaint.startTime) : 0;\r\n  }\r\n\r\n  getFirstContentfulPaint() {\r\n    const paintEntries = performance.getEntriesByType('paint');\r\n    const fcp = paintEntries.find(entry => entry.name === 'first-contentful-paint');\r\n    return fcp ? Math.round(fcp.startTime) : 0;\r\n  }\r\n\r\n  estimateTimeToInteractive() {\r\n    // Simplified TTI estimation\r\n    const navigation = performance.getEntriesByType('navigation')[0];\r\n    return navigation ? Math.round(navigation.domInteractive - navigation.fetchStart) : 0;\r\n  }\r\n\r\n  recordMetric(name, value, metadata = {}) {\r\n    const metric = {\r\n      name,\r\n      value,\r\n      timestamp: Date.now(),\r\n      metadata\r\n    };\r\n\r\n    if (!this.metrics.has(name)) {\r\n      this.metrics.set(name, []);\r\n    }\r\n\r\n    const metrics = this.metrics.get(name);\r\n    metrics.push(metric);\r\n\r\n    // Keep only recent metrics\r\n    const cutoff = Date.now() - this.monitoring.retentionPeriod;\r\n    this.metrics.set(name, metrics.filter(m => m.timestamp > cutoff));\r\n\r\n    // Check thresholds\r\n    this.checkThreshold(name, value);\r\n  }\r\n\r\n  recordPerformanceMetric(entry) {\r\n    const metric = {\r\n      name: entry.name,\r\n      type: entry.entryType,\r\n      startTime: entry.startTime,\r\n      duration: entry.duration,\r\n      timestamp: Date.now()\r\n    };\r\n\r\n    this.recordMetric(`performance.${entry.entryType}`, entry.duration, metric);\r\n\r\n    // Check performance thresholds\r\n    if (entry.entryType === 'navigation' || entry.entryType === 'measure') {\r\n      this.checkThreshold('responseTime', entry.duration);\r\n    }\r\n  }\r\n\r\n  recordError(type, details) {\r\n    const error = {\r\n      type,\r\n      details,\r\n      timestamp: Date.now(),\r\n      url: window.location.href,\r\n      userAgent: navigator.userAgent\r\n    };\r\n\r\n    if (!this.metrics.has('errors')) {\r\n      this.metrics.set('errors', []);\r\n    }\r\n\r\n    this.metrics.get('errors').push(error);\r\n\r\n    // Trigger immediate alert for critical errors\r\n    this.triggerAlert('error', 'critical', `${type} error occurred`, error);\r\n\r\n    logger.error(`Monitoring: ${type} error recorded`, details);\r\n  }\r\n\r\n  checkThreshold(metricName, value) {\r\n    const threshold = this.thresholds[metricName];\r\n    if (!threshold) return;\r\n\r\n    const exceeded = value > threshold;\r\n    if (exceeded) {\r\n      this.triggerAlert('threshold', 'warning',\r\n        `${metricName} threshold exceeded`,\r\n        { metric: metricName, value, threshold }\r\n      );\r\n    }\r\n  }\r\n\r\n  triggerAlert(type, severity, message, data = {}) {\r\n    const alert = {\r\n      id: this.generateAlertId(),\r\n      type,\r\n      severity,\r\n      message,\r\n      data,\r\n      timestamp: Date.now(),\r\n      resolved: false\r\n    };\r\n\r\n    this.alerts.set(alert.id, alert);\r\n\r\n    // Send notifications based on severity\r\n    this.sendAlert(alert);\r\n\r\n    logger.warn(`Alert triggered: ${message}`, alert);\r\n  }\r\n\r\n  async sendAlert(alert) {\r\n    try {\r\n      // Send to configured channels\r\n      for (const channel of this.alertChannels) {\r\n        switch (channel) {\r\n          case 'ui':\r\n            await notificationSystem.error(alert.message, {\r\n              priority: alert.severity === 'critical' ? 'high' : 'medium',\r\n              category: 'monitoring',\r\n              metadata: alert.data\r\n            });\r\n            break;\r\n\r\n          case 'console':\r\n            console.warn('ðŸš¨ MONITORING ALERT:', alert);\r\n            break;\r\n\r\n          case 'storage':\r\n            await this.storeAlert(alert);\r\n            break;\r\n\r\n          case 'webhook':\r\n            await this.sendWebhookAlert(alert);\r\n            break;\r\n        }\r\n      }\r\n    } catch (error) {\r\n      logger.error('Failed to send alert', {\r\n        alertId: alert.id,\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  async runHealthChecks() {\r\n    const results = {};\r\n\r\n    for (const [name, checkFn] of this.healthChecks) {\r\n      try {\r\n        const result = await checkFn();\r\n        results[name] = result;\r\n\r\n        // Trigger alerts for unhealthy systems\r\n        if (result.status === 'unhealthy') {\r\n          this.triggerAlert('health', 'critical',\r\n            `Health check failed: ${name}`,\r\n            result\r\n          );\r\n        }\r\n\r\n      } catch (error) {\r\n        results[name] = {\r\n          status: 'error',\r\n          error: error.message\r\n        };\r\n\r\n        this.triggerAlert('health', 'critical',\r\n          `Health check error: ${name}`,\r\n          { error: error.message }\r\n        );\r\n      }\r\n    }\r\n\r\n    await this.storeHealthCheckResults(results);\r\n    return results;\r\n  }\r\n\r\n  addHealthCheck(name, checkFunction) {\r\n    this.healthChecks.push([name, checkFunction]);\r\n  }\r\n\r\n  removeHealthCheck(name) {\r\n    this.healthChecks = this.healthChecks.filter(([checkName]) => checkName !== name);\r\n  }\r\n\r\n  async processAlerts() {\r\n    const now = Date.now();\r\n    const autoResolveTime = 5 * 60 * 1000; // 5 minutes\r\n\r\n    // Auto-resolve old alerts\r\n    for (const [id, alert] of this.alerts.entries()) {\r\n      if (!alert.resolved && now - alert.timestamp > autoResolveTime) {\r\n        await this.resolveAlert(id);\r\n      }\r\n    }\r\n\r\n    // Clean up old resolved alerts\r\n    const oldAlerts = Array.from(this.alerts.entries())\r\n      .filter(([, alert]) => alert.resolved && now - alert.timestamp > 24 * 60 * 60 * 1000);\r\n\r\n    oldAlerts.forEach(([id]) => this.alerts.delete(id));\r\n  }\r\n\r\n  async resolveAlert(alertId) {\r\n    const alert = this.alerts.get(alertId);\r\n    if (alert) {\r\n      alert.resolved = true;\r\n      alert.resolvedAt = Date.now();\r\n\r\n      logger.info('Alert resolved', { alertId, alert: alert.message });\r\n    }\r\n  }\r\n\r\n  categorizeErrors(errors) {\r\n    const categories = {};\r\n\r\n    errors.forEach(error => {\r\n      const category = error.type || 'unknown';\r\n      categories[category] = (categories[category] || 0) + 1;\r\n    });\r\n\r\n    return categories;\r\n  }\r\n\r\n  analyzeMetrics(metrics) {\r\n    // Analyze trends and patterns\r\n    const analysis = {\r\n      timestamp: metrics.timestamp,\r\n      performance: this.analyzePerformance(metrics.performance),\r\n      errors: this.analyzeErrors(metrics.errors),\r\n      cache: this.analyzeCachePerformance(metrics.cache),\r\n      recommendations: []\r\n    };\r\n\r\n    // Generate recommendations\r\n    if (metrics.performance?.domContentLoaded > 3000) {\r\n      analysis.recommendations.push({\r\n        type: 'performance',\r\n        priority: 'medium',\r\n        message: 'DOM Content Loaded time is high. Consider optimizing JavaScript loading.'\r\n      });\r\n    }\r\n\r\n    if (metrics.errors?.errorRate > this.thresholds.errorRate) {\r\n      analysis.recommendations.push({\r\n        type: 'reliability',\r\n        priority: 'high',\r\n        message: 'Error rate is above threshold. Investigate recent errors.'\r\n      });\r\n    }\r\n\r\n    if (metrics.cache?.hitRate < this.thresholds.cacheHitRate) {\r\n      analysis.recommendations.push({\r\n        type: 'performance',\r\n        priority: 'medium',\r\n        message: 'Cache hit rate is low. Review caching strategy.'\r\n      });\r\n    }\r\n\r\n    return analysis;\r\n  }\r\n\r\n  analyzePerformance(performanceMetrics) {\r\n    if (!performanceMetrics) return null;\r\n\r\n    return {\r\n      score: this.calculatePerformanceScore(performanceMetrics),\r\n      bottlenecks: this.identifyBottlenecks(performanceMetrics),\r\n      trends: this.getPerformanceTrends()\r\n    };\r\n  }\r\n\r\n  calculatePerformanceScore(metrics) {\r\n    let score = 100;\r\n\r\n    // Deduct points for slow metrics\r\n    if (metrics.domContentLoaded > 2000) score -= 20;\r\n    if (metrics.loadComplete > 4000) score -= 20;\r\n    if (metrics.firstContentfulPaint > 1500) score -= 15;\r\n    if (metrics.timeToInteractive > 3000) score -= 25;\r\n\r\n    return Math.max(0, score);\r\n  }\r\n\r\n  identifyBottlenecks(metrics) {\r\n    const bottlenecks = [];\r\n\r\n    if (metrics.domContentLoaded > 3000) {\r\n      bottlenecks.push('Slow DOM content loading');\r\n    }\r\n    if (metrics.firstContentfulPaint > 2000) {\r\n      bottlenecks.push('Slow first paint');\r\n    }\r\n    if (metrics.timeToInteractive > 5000) {\r\n      bottlenecks.push('Slow time to interactive');\r\n    }\r\n\r\n    return bottlenecks;\r\n  }\r\n\r\n  getPerformanceTrends() {\r\n    // Simple trend analysis\r\n    const recentMetrics = this.metrics.get('performance.navigation') || [];\r\n    const last5 = recentMetrics.slice(-5);\r\n\r\n    if (last5.length < 2) return 'insufficient_data';\r\n\r\n    const trend = last5[last5.length - 1].value - last5[0].value;\r\n    return trend > 0 ? 'degrading' : 'improving';\r\n  }\r\n\r\n  analyzeErrors(errorMetrics) {\r\n    if (!errorMetrics) return null;\r\n\r\n    return {\r\n      severity: this.categorizeErrorSeverity(errorMetrics),\r\n      patterns: this.identifyErrorPatterns(errorMetrics),\r\n      frequency: errorMetrics.errorRate\r\n    };\r\n  }\r\n\r\n  categorizeErrorSeverity(errorMetrics) {\r\n    if (errorMetrics.errorRate > 0.1) return 'critical';\r\n    if (errorMetrics.errorRate > 0.05) return 'high';\r\n    if (errorMetrics.errorRate > 0.01) return 'medium';\r\n    return 'low';\r\n  }\r\n\r\n  identifyErrorPatterns(errorMetrics) {\r\n    const errors = this.metrics.get('errors') || [];\r\n    const recentErrors = errors.slice(-10);\r\n\r\n    const patterns = {};\r\n    recentErrors.forEach(error => {\r\n      const pattern = error.details?.message || error.type;\r\n      patterns[pattern] = (patterns[pattern] || 0) + 1;\r\n    });\r\n\r\n    return patterns;\r\n  }\r\n\r\n  analyzeCachePerformance(cacheMetrics) {\r\n    if (!cacheMetrics) return null;\r\n\r\n    return {\r\n      efficiency: cacheMetrics.hitRate || 0,\r\n      utilization: this.calculateCacheUtilization(cacheMetrics),\r\n      recommendations: this.getCacheRecommendations(cacheMetrics)\r\n    };\r\n  }\r\n\r\n  calculateCacheUtilization(metrics) {\r\n    if (!metrics.memorySize || !metrics.maxMemorySize) return 0;\r\n    return metrics.memorySize / metrics.maxMemorySize;\r\n  }\r\n\r\n  getCacheRecommendations(metrics) {\r\n    const recommendations = [];\r\n\r\n    if (metrics.hitRate < 0.7) {\r\n      recommendations.push('Consider adjusting cache TTL values');\r\n    }\r\n    if (metrics.evictions > metrics.sets * 0.1) {\r\n      recommendations.push('Cache size may be too small');\r\n    }\r\n\r\n    return recommendations;\r\n  }\r\n\r\n  monitorNetworkStatus() {\r\n    window.addEventListener('online', () => {\r\n      this.recordMetric('network.status', 1, { status: 'online' });\r\n      logger.info('Network status: online');\r\n    });\r\n\r\n    window.addEventListener('offline', () => {\r\n      this.recordMetric('network.status', 0, { status: 'offline' });\r\n      this.triggerAlert('network', 'warning', 'Network connection lost', {});\r\n      logger.warn('Network status: offline');\r\n    });\r\n  }\r\n\r\n  async storeMetrics(metrics) {\r\n    try {\r\n      const key = `metrics:${Date.now()}`;\r\n      await cacheManager.set(key, metrics, {\r\n        ttl: this.monitoring.retentionPeriod,\r\n        tags: ['metrics']\r\n      });\r\n    } catch (error) {\r\n      logger.error('Failed to store metrics', { error: error.message });\r\n    }\r\n  }\r\n\r\n  async storeAlert(alert) {\r\n    try {\r\n      const key = `alert:${alert.id}`;\r\n      await cacheManager.set(key, alert, {\r\n        ttl: 7 * 24 * 60 * 60 * 1000, // 7 days\r\n        tags: ['alerts']\r\n      });\r\n    } catch (error) {\r\n      logger.error('Failed to store alert', { error: error.message });\r\n    }\r\n  }\r\n\r\n  async storeHealthCheckResults(results) {\r\n    try {\r\n      const key = `health:${Date.now()}`;\r\n      await cacheManager.set(key, results, {\r\n        ttl: 24 * 60 * 60 * 1000, // 24 hours\r\n        tags: ['health']\r\n      });\r\n    } catch (error) {\r\n      logger.error('Failed to store health check results', { error: error.message });\r\n    }\r\n  }\r\n\r\n  async sendWebhookAlert(alert) {\r\n    // Placeholder for webhook integration\r\n    logger.info('Webhook alert would be sent', alert);\r\n  }\r\n\r\n  generateAlertId() {\r\n    return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  async cleanupOldMetrics() {\r\n    try {\r\n      const cutoff = Date.now() - this.monitoring.retentionPeriod;\r\n\r\n      // Clean up in-memory metrics\r\n      for (const [name, metrics] of this.metrics.entries()) {\r\n        const filtered = metrics.filter(m => m.timestamp > cutoff);\r\n        this.metrics.set(name, filtered);\r\n      }\r\n\r\n      // Clean up cached metrics\r\n      await cacheManager.deleteByTags(['metrics']);\r\n\r\n      logger.debug('Old metrics cleaned up', { cutoff: new Date(cutoff) });\r\n    } catch (error) {\r\n      logger.error('Failed to cleanup old metrics', { error: error.message });\r\n    }\r\n  }\r\n\r\n  async getSystemReport() {\r\n    try {\r\n      const healthChecks = await this.runHealthChecks();\r\n      const recentMetrics = await this.getRecentMetrics();\r\n      const activeAlerts = Array.from(this.alerts.values())\r\n        .filter(alert => !alert.resolved);\r\n\r\n      return {\r\n        timestamp: Date.now(),\r\n        systemHealth: this.calculateOverallHealth(healthChecks),\r\n        healthChecks,\r\n        metrics: recentMetrics,\r\n        alerts: {\r\n          active: activeAlerts.length,\r\n          critical: activeAlerts.filter(a => a.severity === 'critical').length,\r\n          warnings: activeAlerts.filter(a => a.severity === 'warning').length\r\n        },\r\n        performance: await this.getPerformanceSummary(),\r\n        recommendations: this.getSystemRecommendations(healthChecks, recentMetrics)\r\n      };\r\n    } catch (error) {\r\n      logger.error('Failed to generate system report', { error: error.message });\r\n      return { error: error.message };\r\n    }\r\n  }\r\n\r\n  calculateOverallHealth(healthChecks) {\r\n    const statuses = Object.values(healthChecks).map(check => check.status);\r\n    const healthy = statuses.filter(status => status === 'healthy').length;\r\n    const total = statuses.length;\r\n\r\n    if (statuses.includes('unhealthy')) return 'critical';\r\n    if (statuses.includes('degraded')) return 'degraded';\r\n    if (healthy === total) return 'healthy';\r\n    return 'unknown';\r\n  }\r\n\r\n  async getRecentMetrics() {\r\n    const recent = {};\r\n    for (const [name, metrics] of this.metrics.entries()) {\r\n      const recentMetrics = metrics.slice(-5);\r\n      if (recentMetrics.length > 0) {\r\n        recent[name] = {\r\n          latest: recentMetrics[recentMetrics.length - 1],\r\n          count: recentMetrics.length,\r\n          average: recentMetrics.reduce((sum, m) => sum + m.value, 0) / recentMetrics.length\r\n        };\r\n      }\r\n    }\r\n    return recent;\r\n  }\r\n\r\n  async getPerformanceSummary() {\r\n    const navigation = performance.getEntriesByType('navigation')[0];\r\n    if (!navigation) return null;\r\n\r\n    return {\r\n      pageLoad: Math.round(navigation.loadEventEnd - navigation.fetchStart),\r\n      domReady: Math.round(navigation.domContentLoadedEventEnd - navigation.fetchStart),\r\n      firstPaint: this.getFirstPaint(),\r\n      score: this.calculatePerformanceScore({\r\n        domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,\r\n        loadComplete: navigation.loadEventEnd - navigation.loadEventStart,\r\n        firstContentfulPaint: this.getFirstContentfulPaint(),\r\n        timeToInteractive: navigation.domInteractive - navigation.fetchStart\r\n      })\r\n    };\r\n  }\r\n\r\n  getSystemRecommendations(healthChecks, metrics) {\r\n    const recommendations = [];\r\n\r\n    // Health-based recommendations\r\n    Object.entries(healthChecks).forEach(([name, check]) => {\r\n      if (check.status === 'unhealthy') {\r\n        recommendations.push({\r\n          type: 'critical',\r\n          component: name,\r\n          message: `${name} is unhealthy and requires immediate attention`\r\n        });\r\n      }\r\n    });\r\n\r\n    // Metric-based recommendations\r\n    if (metrics['memory.usage']?.latest?.value > 0.8) {\r\n      recommendations.push({\r\n        type: 'warning',\r\n        component: 'memory',\r\n        message: 'Memory usage is high. Consider clearing caches or reducing data retention.'\r\n      });\r\n    }\r\n\r\n    return recommendations;\r\n  }\r\n\r\n  setThreshold(metric, value) {\r\n    this.thresholds[metric] = value;\r\n    logger.info('Threshold updated', { metric, value });\r\n  }\r\n\r\n  setMonitoringEnabled(enabled) {\r\n    this.monitoring.enabled = enabled;\r\n    logger.info(`Monitoring ${enabled ? 'enabled' : 'disabled'}`);\r\n  }\r\n\r\n  addAlertChannel(channel) {\r\n    if (!this.alertChannels.includes(channel)) {\r\n      this.alertChannels.push(channel);\r\n      logger.info('Alert channel added', { channel });\r\n    }\r\n  }\r\n\r\n  removeAlertChannel(channel) {\r\n    this.alertChannels = this.alertChannels.filter(c => c !== channel);\r\n    logger.info('Alert channel removed', { channel });\r\n  }\r\n\r\n  destroy() {\r\n    if (this.performanceObserver) {\r\n      this.performanceObserver.disconnect();\r\n    }\r\n\r\n    this.monitoring.enabled = false;\r\n    logger.info('Enterprise Monitoring System destroyed');\r\n  }\r\n}\r\n\r\nconst enterpriseMonitoring = new EnterpriseMonitoringSystem();\r\n\r\nexport default enterpriseMonitoring;\r\nexport { EnterpriseMonitoringSystem };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}