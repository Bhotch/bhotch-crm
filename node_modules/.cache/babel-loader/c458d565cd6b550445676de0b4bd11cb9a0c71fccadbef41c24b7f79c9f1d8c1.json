{"ast":null,"code":"import cacheManager from './advancedCache';\nimport securityManager from './securityManager';\nimport logger from './enterpriseLogger';\nclass BackupRecoverySystem {\n  constructor() {\n    this.backupPrefix = 'backup_';\n    this.maxBackups = 10;\n    this.autoBackupInterval = 6 * 60 * 60 * 1000; // 6 hours\n    this.compressionThreshold = 10000; // bytes\n    this.encryptionEnabled = true;\n    this.initializeBackupSystem();\n  }\n  initializeBackupSystem() {\n    // Schedule automatic backups\n    this.scheduleAutoBackups();\n\n    // Listen for critical data changes\n    this.setupDataChangeListeners();\n\n    // Register cleanup tasks\n    this.scheduleCleanup();\n    logger.info('Backup and Recovery System initialized', {\n      autoBackupInterval: this.autoBackupInterval,\n      maxBackups: this.maxBackups,\n      encryptionEnabled: this.encryptionEnabled\n    });\n  }\n  scheduleAutoBackups() {\n    setInterval(async () => {\n      try {\n        await this.createAutoBackup();\n        logger.info('Automatic backup completed successfully');\n      } catch (error) {\n        logger.error('Automatic backup failed', {\n          error: error.message\n        });\n      }\n    }, this.autoBackupInterval);\n\n    // Create initial backup after 30 seconds\n    setTimeout(() => this.createAutoBackup(), 30000);\n  }\n  setupDataChangeListeners() {\n    // Listen for storage events\n    window.addEventListener('storage', event => {\n      if (this.isCriticalData(event.key)) {\n        this.scheduleIncrementalBackup(event.key);\n      }\n    });\n\n    // Listen for beforeunload to create emergency backup\n    window.addEventListener('beforeunload', () => {\n      this.createEmergencyBackup();\n    });\n  }\n  scheduleCleanup() {\n    // Clean old backups daily\n    setInterval(() => {\n      this.cleanupOldBackups();\n    }, 24 * 60 * 60 * 1000);\n  }\n  isCriticalData(key) {\n    const criticalPrefixes = ['leads_', 'jobCounts_', 'calculations_', 'userSettings_'];\n    return criticalPrefixes.some(prefix => key === null || key === void 0 ? void 0 : key.startsWith(prefix));\n  }\n  async createFullBackup(backupName = null) {\n    const startTime = performance.now();\n    try {\n      const backupId = backupName || `full_${Date.now()}`;\n      const timestamp = new Date().toISOString();\n      logger.info('Starting full backup', {\n        backupId\n      });\n\n      // Collect all data sources\n      const backupData = {\n        metadata: {\n          backupId,\n          timestamp,\n          type: 'full',\n          version: '1.0',\n          source: 'Ultimate CRM'\n        },\n        localStorage: await this.backupLocalStorage(),\n        sessionStorage: await this.backupSessionStorage(),\n        indexedDB: await this.backupIndexedDB(),\n        cache: await this.backupCacheData(),\n        settings: await this.backupUserSettings(),\n        calculations: await this.backupCalculations()\n      };\n\n      // Calculate backup size and checksum\n      const serializedData = JSON.stringify(backupData);\n      backupData.metadata.size = serializedData.length;\n      backupData.metadata.checksum = this.calculateChecksum(serializedData);\n\n      // Compress if needed\n      const finalData = this.shouldCompress(serializedData) ? this.compressData(backupData) : backupData;\n\n      // Encrypt backup\n      const encryptedBackup = this.encryptionEnabled ? securityManager.encryptBackupData(finalData) : finalData;\n\n      // Store backup\n      const backupKey = `${this.backupPrefix}${backupId}`;\n      await this.storeBackup(backupKey, encryptedBackup);\n\n      // Update backup registry\n      await this.updateBackupRegistry(backupId, {\n        timestamp,\n        type: 'full',\n        size: backupData.metadata.size,\n        compressed: this.shouldCompress(serializedData),\n        encrypted: this.encryptionEnabled\n      });\n      const duration = performance.now() - startTime;\n      logger.info('Full backup completed', {\n        backupId,\n        duration: Math.round(duration),\n        size: backupData.metadata.size,\n        compressed: this.shouldCompress(serializedData)\n      });\n      return {\n        success: true,\n        backupId,\n        size: backupData.metadata.size,\n        duration\n      };\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      logger.error('Full backup failed', {\n        error: error.message,\n        duration: Math.round(duration)\n      });\n      return {\n        success: false,\n        error: error.message,\n        duration\n      };\n    }\n  }\n  async createIncrementalBackup(changedKeys = []) {\n    const startTime = performance.now();\n    try {\n      const backupId = `incremental_${Date.now()}`;\n      const timestamp = new Date().toISOString();\n      logger.info('Starting incremental backup', {\n        backupId,\n        changedKeys\n      });\n      const backupData = {\n        metadata: {\n          backupId,\n          timestamp,\n          type: 'incremental',\n          version: '1.0',\n          changedKeys\n        },\n        changes: {}\n      };\n\n      // Backup only changed data\n      for (const key of changedKeys) {\n        if (key.startsWith('localStorage_')) {\n          const actualKey = key.substring(13);\n          backupData.changes[key] = localStorage.getItem(actualKey);\n        } else if (key.startsWith('sessionStorage_')) {\n          const actualKey = key.substring(15);\n          backupData.changes[key] = sessionStorage.getItem(actualKey);\n        }\n      }\n      const serializedData = JSON.stringify(backupData);\n      backupData.metadata.size = serializedData.length;\n      backupData.metadata.checksum = this.calculateChecksum(serializedData);\n      const encryptedBackup = this.encryptionEnabled ? securityManager.encryptBackupData(backupData) : backupData;\n      const backupKey = `${this.backupPrefix}${backupId}`;\n      await this.storeBackup(backupKey, encryptedBackup);\n      await this.updateBackupRegistry(backupId, {\n        timestamp,\n        type: 'incremental',\n        size: backupData.metadata.size,\n        changedKeys\n      });\n      const duration = performance.now() - startTime;\n      logger.info('Incremental backup completed', {\n        backupId,\n        duration: Math.round(duration),\n        size: backupData.metadata.size\n      });\n      return {\n        success: true,\n        backupId,\n        size: backupData.metadata.size\n      };\n    } catch (error) {\n      logger.error('Incremental backup failed', {\n        error: error.message\n      });\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n  async createAutoBackup() {\n    return await this.createFullBackup(`auto_${Date.now()}`);\n  }\n  createEmergencyBackup() {\n    // Synchronous emergency backup using basic localStorage\n    try {\n      const emergencyData = {\n        timestamp: Date.now(),\n        localStorage: {\n          ...localStorage\n        },\n        sessionStorage: {\n          ...sessionStorage\n        }\n      };\n      localStorage.setItem('emergencyBackup', JSON.stringify(emergencyData));\n      logger.info('Emergency backup created');\n    } catch (error) {\n      console.error('Emergency backup failed:', error);\n    }\n  }\n  async scheduleIncrementalBackup(changedKey) {\n    // Debounce multiple rapid changes\n    if (this.incrementalTimeout) {\n      clearTimeout(this.incrementalTimeout);\n    }\n    if (!this.changedKeys) {\n      this.changedKeys = new Set();\n    }\n    this.changedKeys.add(changedKey);\n    this.incrementalTimeout = setTimeout(async () => {\n      const keys = Array.from(this.changedKeys);\n      this.changedKeys.clear();\n      await this.createIncrementalBackup(keys);\n    }, 30000); // 30 second delay\n  }\n  async restoreFromBackup(backupId, options = {}) {\n    const startTime = performance.now();\n    try {\n      const {\n        dryRun = false,\n        skipConfirmation = false,\n        selectiveRestore = null\n      } = options;\n      logger.info('Starting restore operation', {\n        backupId,\n        dryRun\n      });\n      if (!skipConfirmation && !dryRun) {\n        const confirmed = confirm(`Are you sure you want to restore from backup \"${backupId}\"? This will overwrite current data.`);\n        if (!confirmed) {\n          return {\n            success: false,\n            cancelled: true\n          };\n        }\n      }\n\n      // Retrieve backup\n      const backupKey = `${this.backupPrefix}${backupId}`;\n      const encryptedBackup = await this.retrieveBackup(backupKey);\n      if (!encryptedBackup) {\n        throw new Error(`Backup \"${backupId}\" not found`);\n      }\n\n      // Decrypt backup\n      const backupData = this.encryptionEnabled ? securityManager.decryptSensitiveData(encryptedBackup) : encryptedBackup;\n\n      // Validate backup integrity\n      const isValid = await this.validateBackupIntegrity(backupData);\n      if (!isValid) {\n        throw new Error('Backup integrity validation failed');\n      }\n      if (dryRun) {\n        return {\n          success: true,\n          dryRun: true,\n          metadata: backupData.metadata,\n          dataKeys: Object.keys(backupData).filter(key => key !== 'metadata')\n        };\n      }\n\n      // Create pre-restore backup\n      await this.createFullBackup(`pre_restore_${Date.now()}`);\n\n      // Perform restoration\n      await this.performRestore(backupData, selectiveRestore);\n      const duration = performance.now() - startTime;\n      logger.info('Restore completed successfully', {\n        backupId,\n        duration: Math.round(duration)\n      });\n      return {\n        success: true,\n        backupId,\n        restoredAt: new Date().toISOString(),\n        duration\n      };\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      logger.error('Restore operation failed', {\n        backupId,\n        error: error.message,\n        duration: Math.round(duration)\n      });\n      return {\n        success: false,\n        error: error.message,\n        duration\n      };\n    }\n  }\n  async performRestore(backupData, selectiveRestore) {\n    const {\n      metadata,\n      localStorage: lsData,\n      sessionStorage: ssData,\n      indexedDB,\n      cache\n    } = backupData;\n\n    // Restore localStorage\n    if ((!selectiveRestore || selectiveRestore.includes('localStorage')) && lsData) {\n      Object.entries(lsData).forEach(([key, value]) => {\n        if (value !== null) {\n          localStorage.setItem(key, value);\n        }\n      });\n    }\n\n    // Restore sessionStorage\n    if ((!selectiveRestore || selectiveRestore.includes('sessionStorage')) && ssData) {\n      Object.entries(ssData).forEach(([key, value]) => {\n        if (value !== null) {\n          sessionStorage.setItem(key, value);\n        }\n      });\n    }\n\n    // Restore IndexedDB\n    if ((!selectiveRestore || selectiveRestore.includes('indexedDB')) && indexedDB) {\n      await this.restoreIndexedDB(indexedDB);\n    }\n\n    // Restore cache\n    if ((!selectiveRestore || selectiveRestore.includes('cache')) && cache) {\n      await this.restoreCache(cache);\n    }\n    logger.info('Data restoration completed', {\n      restoredSections: selectiveRestore || ['all']\n    });\n  }\n  async backupLocalStorage() {\n    const data = {};\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      data[key] = localStorage.getItem(key);\n    }\n    return data;\n  }\n  async backupSessionStorage() {\n    const data = {};\n    for (let i = 0; i < sessionStorage.length; i++) {\n      const key = sessionStorage.key(i);\n      data[key] = sessionStorage.getItem(key);\n    }\n    return data;\n  }\n  async backupIndexedDB() {\n    try {\n      // Backup cache database\n      const cacheKeys = await cacheManager.keys('*');\n      const cacheData = {};\n      for (const key of cacheKeys) {\n        cacheData[key] = await cacheManager.get(key);\n      }\n      return cacheData;\n    } catch (error) {\n      logger.warn('IndexedDB backup failed', {\n        error: error.message\n      });\n      return {};\n    }\n  }\n  async backupCacheData() {\n    try {\n      return await cacheManager.getStats();\n    } catch (error) {\n      logger.warn('Cache backup failed', {\n        error: error.message\n      });\n      return {};\n    }\n  }\n  async backupUserSettings() {\n    return {\n      theme: localStorage.getItem('theme'),\n      language: localStorage.getItem('language'),\n      preferences: localStorage.getItem('userPreferences'),\n      settings: localStorage.getItem('appSettings')\n    };\n  }\n  async backupCalculations() {\n    try {\n      const calculationKeys = await cacheManager.keys('calculation:*');\n      const calculations = {};\n      for (const key of calculationKeys) {\n        calculations[key] = await cacheManager.get(key);\n      }\n      return calculations;\n    } catch (error) {\n      logger.warn('Calculations backup failed', {\n        error: error.message\n      });\n      return {};\n    }\n  }\n  async restoreIndexedDB(indexedDBData) {\n    try {\n      for (const [key, value] of Object.entries(indexedDBData)) {\n        await cacheManager.set(key, value, {\n          ttl: 24 * 60 * 60 * 1000\n        });\n      }\n    } catch (error) {\n      logger.error('IndexedDB restore failed', {\n        error: error.message\n      });\n    }\n  }\n  async restoreCache(cacheData) {\n    try {\n      // Cache stats are informational only, no restoration needed\n      logger.info('Cache stats from backup', cacheData);\n    } catch (error) {\n      logger.error('Cache restore failed', {\n        error: error.message\n      });\n    }\n  }\n  shouldCompress(data) {\n    return data.length > this.compressionThreshold;\n  }\n  compressData(data) {\n    try {\n      return {\n        compressed: true,\n        data: JSON.stringify(data) // Simple JSON compression\n      };\n    } catch (error) {\n      logger.warn('Compression failed', {\n        error: error.message\n      });\n      return data;\n    }\n  }\n  decompressData(compressedData) {\n    try {\n      if (compressedData.compressed) {\n        return JSON.parse(compressedData.data);\n      }\n      return compressedData;\n    } catch (error) {\n      logger.error('Decompression failed', {\n        error: error.message\n      });\n      return compressedData;\n    }\n  }\n  calculateChecksum(data) {\n    let hash = 0;\n    for (let i = 0; i < data.length; i++) {\n      const char = data.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash;\n    }\n    return hash.toString(16);\n  }\n  async validateBackupIntegrity(backupData) {\n    try {\n      if (!backupData.metadata) {\n        logger.warn('Backup missing metadata');\n        return false;\n      }\n      const {\n        checksum,\n        size\n      } = backupData.metadata;\n      const currentData = JSON.stringify(backupData);\n      if (size && currentData.length !== size) {\n        logger.warn('Backup size mismatch', {\n          expected: size,\n          actual: currentData.length\n        });\n      }\n      if (checksum) {\n        const currentChecksum = this.calculateChecksum(currentData);\n        if (currentChecksum !== checksum) {\n          logger.error('Backup checksum validation failed', {\n            expected: checksum,\n            actual: currentChecksum\n          });\n          return false;\n        }\n      }\n      return true;\n    } catch (error) {\n      logger.error('Backup validation failed', {\n        error: error.message\n      });\n      return false;\n    }\n  }\n  async storeBackup(key, data) {\n    await cacheManager.set(key, data, {\n      ttl: 30 * 24 * 60 * 60 * 1000,\n      // 30 days\n      tags: ['backup']\n    });\n  }\n  async retrieveBackup(key) {\n    return await cacheManager.get(key);\n  }\n  async updateBackupRegistry(backupId, metadata) {\n    try {\n      const registry = (await cacheManager.get('backup_registry')) || {};\n      registry[backupId] = metadata;\n      await cacheManager.set('backup_registry', registry, {\n        ttl: 30 * 24 * 60 * 60 * 1000,\n        tags: ['backup', 'registry']\n      });\n    } catch (error) {\n      logger.error('Failed to update backup registry', {\n        error: error.message\n      });\n    }\n  }\n  async getBackupList() {\n    try {\n      const registry = (await cacheManager.get('backup_registry')) || {};\n      return Object.entries(registry).map(([id, metadata]) => ({\n        id,\n        ...metadata\n      })).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));\n    } catch (error) {\n      logger.error('Failed to get backup list', {\n        error: error.message\n      });\n      return [];\n    }\n  }\n  async deleteBackup(backupId) {\n    try {\n      const backupKey = `${this.backupPrefix}${backupId}`;\n      await cacheManager.delete(backupKey);\n      const registry = (await cacheManager.get('backup_registry')) || {};\n      delete registry[backupId];\n      await cacheManager.set('backup_registry', registry);\n      logger.info('Backup deleted', {\n        backupId\n      });\n      return {\n        success: true\n      };\n    } catch (error) {\n      logger.error('Failed to delete backup', {\n        backupId,\n        error: error.message\n      });\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n  async cleanupOldBackups() {\n    try {\n      const backups = await this.getBackupList();\n      const backupsToDelete = backups.slice(this.maxBackups);\n      for (const backup of backupsToDelete) {\n        await this.deleteBackup(backup.id);\n      }\n      logger.info('Backup cleanup completed', {\n        totalBackups: backups.length,\n        deletedBackups: backupsToDelete.length,\n        remainingBackups: Math.min(backups.length, this.maxBackups)\n      });\n      return backupsToDelete.length;\n    } catch (error) {\n      logger.error('Backup cleanup failed', {\n        error: error.message\n      });\n      return 0;\n    }\n  }\n  async getSystemHealth() {\n    try {\n      const backups = await this.getBackupList();\n      const lastBackup = backups[0];\n      const backupStats = await cacheManager.getStats();\n      return {\n        totalBackups: backups.length,\n        lastBackup: lastBackup ? {\n          id: lastBackup.id,\n          timestamp: lastBackup.timestamp,\n          type: lastBackup.type,\n          size: lastBackup.size\n        } : null,\n        autoBackupEnabled: !!this.autoBackupInterval,\n        nextAutoBackup: this.getNextBackupTime(),\n        storageHealth: backupStats,\n        encryptionEnabled: this.encryptionEnabled\n      };\n    } catch (error) {\n      logger.error('Failed to get system health', {\n        error: error.message\n      });\n      return {\n        error: error.message\n      };\n    }\n  }\n  getNextBackupTime() {\n    // Calculate next auto backup time\n    const now = Date.now();\n    const lastAutoBackupTime = this.lastAutoBackupTime || now;\n    return new Date(lastAutoBackupTime + this.autoBackupInterval).toISOString();\n  }\n  destroy() {\n    if (this.incrementalTimeout) {\n      clearTimeout(this.incrementalTimeout);\n    }\n    logger.info('Backup and Recovery System destroyed');\n  }\n}\nconst backupRecoverySystem = new BackupRecoverySystem();\nexport default backupRecoverySystem;\nexport { BackupRecoverySystem };","map":{"version":3,"names":["cacheManager","securityManager","logger","BackupRecoverySystem","constructor","backupPrefix","maxBackups","autoBackupInterval","compressionThreshold","encryptionEnabled","initializeBackupSystem","scheduleAutoBackups","setupDataChangeListeners","scheduleCleanup","info","setInterval","createAutoBackup","error","message","setTimeout","window","addEventListener","event","isCriticalData","key","scheduleIncrementalBackup","createEmergencyBackup","cleanupOldBackups","criticalPrefixes","some","prefix","startsWith","createFullBackup","backupName","startTime","performance","now","backupId","Date","timestamp","toISOString","backupData","metadata","type","version","source","localStorage","backupLocalStorage","sessionStorage","backupSessionStorage","indexedDB","backupIndexedDB","cache","backupCacheData","settings","backupUserSettings","calculations","backupCalculations","serializedData","JSON","stringify","size","length","checksum","calculateChecksum","finalData","shouldCompress","compressData","encryptedBackup","encryptBackupData","backupKey","storeBackup","updateBackupRegistry","compressed","encrypted","duration","Math","round","success","createIncrementalBackup","changedKeys","changes","actualKey","substring","getItem","emergencyData","setItem","console","changedKey","incrementalTimeout","clearTimeout","Set","add","keys","Array","from","clear","restoreFromBackup","options","dryRun","skipConfirmation","selectiveRestore","confirmed","confirm","cancelled","retrieveBackup","Error","decryptSensitiveData","isValid","validateBackupIntegrity","dataKeys","Object","filter","performRestore","restoredAt","lsData","ssData","includes","entries","forEach","value","restoreIndexedDB","restoreCache","restoredSections","data","i","cacheKeys","cacheData","get","warn","getStats","theme","language","preferences","calculationKeys","indexedDBData","set","ttl","decompressData","compressedData","parse","hash","char","charCodeAt","toString","currentData","expected","actual","currentChecksum","tags","registry","getBackupList","map","id","sort","a","b","deleteBackup","delete","backups","backupsToDelete","slice","backup","totalBackups","deletedBackups","remainingBackups","min","getSystemHealth","lastBackup","backupStats","autoBackupEnabled","nextAutoBackup","getNextBackupTime","storageHealth","lastAutoBackupTime","destroy","backupRecoverySystem"],"sources":["C:/Users/PC_User/Desktop/free-crm/bhotch-crm/src/utils/backupRecoverySystem.js"],"sourcesContent":["import cacheManager from './advancedCache';\r\nimport securityManager from './securityManager';\r\nimport logger from './enterpriseLogger';\r\n\r\nclass BackupRecoverySystem {\r\n  constructor() {\r\n    this.backupPrefix = 'backup_';\r\n    this.maxBackups = 10;\r\n    this.autoBackupInterval = 6 * 60 * 60 * 1000; // 6 hours\r\n    this.compressionThreshold = 10000; // bytes\r\n    this.encryptionEnabled = true;\r\n\r\n    this.initializeBackupSystem();\r\n  }\r\n\r\n  initializeBackupSystem() {\r\n    // Schedule automatic backups\r\n    this.scheduleAutoBackups();\r\n\r\n    // Listen for critical data changes\r\n    this.setupDataChangeListeners();\r\n\r\n    // Register cleanup tasks\r\n    this.scheduleCleanup();\r\n\r\n    logger.info('Backup and Recovery System initialized', {\r\n      autoBackupInterval: this.autoBackupInterval,\r\n      maxBackups: this.maxBackups,\r\n      encryptionEnabled: this.encryptionEnabled\r\n    });\r\n  }\r\n\r\n  scheduleAutoBackups() {\r\n    setInterval(async () => {\r\n      try {\r\n        await this.createAutoBackup();\r\n        logger.info('Automatic backup completed successfully');\r\n      } catch (error) {\r\n        logger.error('Automatic backup failed', { error: error.message });\r\n      }\r\n    }, this.autoBackupInterval);\r\n\r\n    // Create initial backup after 30 seconds\r\n    setTimeout(() => this.createAutoBackup(), 30000);\r\n  }\r\n\r\n  setupDataChangeListeners() {\r\n    // Listen for storage events\r\n    window.addEventListener('storage', (event) => {\r\n      if (this.isCriticalData(event.key)) {\r\n        this.scheduleIncrementalBackup(event.key);\r\n      }\r\n    });\r\n\r\n    // Listen for beforeunload to create emergency backup\r\n    window.addEventListener('beforeunload', () => {\r\n      this.createEmergencyBackup();\r\n    });\r\n  }\r\n\r\n  scheduleCleanup() {\r\n    // Clean old backups daily\r\n    setInterval(() => {\r\n      this.cleanupOldBackups();\r\n    }, 24 * 60 * 60 * 1000);\r\n  }\r\n\r\n  isCriticalData(key) {\r\n    const criticalPrefixes = ['leads_', 'jobCounts_', 'calculations_', 'userSettings_'];\r\n    return criticalPrefixes.some(prefix => key?.startsWith(prefix));\r\n  }\r\n\r\n  async createFullBackup(backupName = null) {\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      const backupId = backupName || `full_${Date.now()}`;\r\n      const timestamp = new Date().toISOString();\r\n\r\n      logger.info('Starting full backup', { backupId });\r\n\r\n      // Collect all data sources\r\n      const backupData = {\r\n        metadata: {\r\n          backupId,\r\n          timestamp,\r\n          type: 'full',\r\n          version: '1.0',\r\n          source: 'Ultimate CRM'\r\n        },\r\n        localStorage: await this.backupLocalStorage(),\r\n        sessionStorage: await this.backupSessionStorage(),\r\n        indexedDB: await this.backupIndexedDB(),\r\n        cache: await this.backupCacheData(),\r\n        settings: await this.backupUserSettings(),\r\n        calculations: await this.backupCalculations()\r\n      };\r\n\r\n      // Calculate backup size and checksum\r\n      const serializedData = JSON.stringify(backupData);\r\n      backupData.metadata.size = serializedData.length;\r\n      backupData.metadata.checksum = this.calculateChecksum(serializedData);\r\n\r\n      // Compress if needed\r\n      const finalData = this.shouldCompress(serializedData) ?\r\n        this.compressData(backupData) : backupData;\r\n\r\n      // Encrypt backup\r\n      const encryptedBackup = this.encryptionEnabled ?\r\n        securityManager.encryptBackupData(finalData) : finalData;\r\n\r\n      // Store backup\r\n      const backupKey = `${this.backupPrefix}${backupId}`;\r\n      await this.storeBackup(backupKey, encryptedBackup);\r\n\r\n      // Update backup registry\r\n      await this.updateBackupRegistry(backupId, {\r\n        timestamp,\r\n        type: 'full',\r\n        size: backupData.metadata.size,\r\n        compressed: this.shouldCompress(serializedData),\r\n        encrypted: this.encryptionEnabled\r\n      });\r\n\r\n      const duration = performance.now() - startTime;\r\n      logger.info('Full backup completed', {\r\n        backupId,\r\n        duration: Math.round(duration),\r\n        size: backupData.metadata.size,\r\n        compressed: this.shouldCompress(serializedData)\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        backupId,\r\n        size: backupData.metadata.size,\r\n        duration\r\n      };\r\n\r\n    } catch (error) {\r\n      const duration = performance.now() - startTime;\r\n      logger.error('Full backup failed', {\r\n        error: error.message,\r\n        duration: Math.round(duration)\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        error: error.message,\r\n        duration\r\n      };\r\n    }\r\n  }\r\n\r\n  async createIncrementalBackup(changedKeys = []) {\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      const backupId = `incremental_${Date.now()}`;\r\n      const timestamp = new Date().toISOString();\r\n\r\n      logger.info('Starting incremental backup', { backupId, changedKeys });\r\n\r\n      const backupData = {\r\n        metadata: {\r\n          backupId,\r\n          timestamp,\r\n          type: 'incremental',\r\n          version: '1.0',\r\n          changedKeys\r\n        },\r\n        changes: {}\r\n      };\r\n\r\n      // Backup only changed data\r\n      for (const key of changedKeys) {\r\n        if (key.startsWith('localStorage_')) {\r\n          const actualKey = key.substring(13);\r\n          backupData.changes[key] = localStorage.getItem(actualKey);\r\n        } else if (key.startsWith('sessionStorage_')) {\r\n          const actualKey = key.substring(15);\r\n          backupData.changes[key] = sessionStorage.getItem(actualKey);\r\n        }\r\n      }\r\n\r\n      const serializedData = JSON.stringify(backupData);\r\n      backupData.metadata.size = serializedData.length;\r\n      backupData.metadata.checksum = this.calculateChecksum(serializedData);\r\n\r\n      const encryptedBackup = this.encryptionEnabled ?\r\n        securityManager.encryptBackupData(backupData) : backupData;\r\n\r\n      const backupKey = `${this.backupPrefix}${backupId}`;\r\n      await this.storeBackup(backupKey, encryptedBackup);\r\n\r\n      await this.updateBackupRegistry(backupId, {\r\n        timestamp,\r\n        type: 'incremental',\r\n        size: backupData.metadata.size,\r\n        changedKeys\r\n      });\r\n\r\n      const duration = performance.now() - startTime;\r\n      logger.info('Incremental backup completed', {\r\n        backupId,\r\n        duration: Math.round(duration),\r\n        size: backupData.metadata.size\r\n      });\r\n\r\n      return { success: true, backupId, size: backupData.metadata.size };\r\n\r\n    } catch (error) {\r\n      logger.error('Incremental backup failed', { error: error.message });\r\n      return { success: false, error: error.message };\r\n    }\r\n  }\r\n\r\n  async createAutoBackup() {\r\n    return await this.createFullBackup(`auto_${Date.now()}`);\r\n  }\r\n\r\n  createEmergencyBackup() {\r\n    // Synchronous emergency backup using basic localStorage\r\n    try {\r\n      const emergencyData = {\r\n        timestamp: Date.now(),\r\n        localStorage: { ...localStorage },\r\n        sessionStorage: { ...sessionStorage }\r\n      };\r\n\r\n      localStorage.setItem('emergencyBackup', JSON.stringify(emergencyData));\r\n      logger.info('Emergency backup created');\r\n    } catch (error) {\r\n      console.error('Emergency backup failed:', error);\r\n    }\r\n  }\r\n\r\n  async scheduleIncrementalBackup(changedKey) {\r\n    // Debounce multiple rapid changes\r\n    if (this.incrementalTimeout) {\r\n      clearTimeout(this.incrementalTimeout);\r\n    }\r\n\r\n    if (!this.changedKeys) {\r\n      this.changedKeys = new Set();\r\n    }\r\n\r\n    this.changedKeys.add(changedKey);\r\n\r\n    this.incrementalTimeout = setTimeout(async () => {\r\n      const keys = Array.from(this.changedKeys);\r\n      this.changedKeys.clear();\r\n      await this.createIncrementalBackup(keys);\r\n    }, 30000); // 30 second delay\r\n  }\r\n\r\n  async restoreFromBackup(backupId, options = {}) {\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      const {\r\n        dryRun = false,\r\n        skipConfirmation = false,\r\n        selectiveRestore = null\r\n      } = options;\r\n\r\n      logger.info('Starting restore operation', { backupId, dryRun });\r\n\r\n      if (!skipConfirmation && !dryRun) {\r\n        const confirmed = confirm(\r\n          `Are you sure you want to restore from backup \"${backupId}\"? This will overwrite current data.`\r\n        );\r\n        if (!confirmed) {\r\n          return { success: false, cancelled: true };\r\n        }\r\n      }\r\n\r\n      // Retrieve backup\r\n      const backupKey = `${this.backupPrefix}${backupId}`;\r\n      const encryptedBackup = await this.retrieveBackup(backupKey);\r\n\r\n      if (!encryptedBackup) {\r\n        throw new Error(`Backup \"${backupId}\" not found`);\r\n      }\r\n\r\n      // Decrypt backup\r\n      const backupData = this.encryptionEnabled ?\r\n        securityManager.decryptSensitiveData(encryptedBackup) : encryptedBackup;\r\n\r\n      // Validate backup integrity\r\n      const isValid = await this.validateBackupIntegrity(backupData);\r\n      if (!isValid) {\r\n        throw new Error('Backup integrity validation failed');\r\n      }\r\n\r\n      if (dryRun) {\r\n        return {\r\n          success: true,\r\n          dryRun: true,\r\n          metadata: backupData.metadata,\r\n          dataKeys: Object.keys(backupData).filter(key => key !== 'metadata')\r\n        };\r\n      }\r\n\r\n      // Create pre-restore backup\r\n      await this.createFullBackup(`pre_restore_${Date.now()}`);\r\n\r\n      // Perform restoration\r\n      await this.performRestore(backupData, selectiveRestore);\r\n\r\n      const duration = performance.now() - startTime;\r\n      logger.info('Restore completed successfully', {\r\n        backupId,\r\n        duration: Math.round(duration)\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        backupId,\r\n        restoredAt: new Date().toISOString(),\r\n        duration\r\n      };\r\n\r\n    } catch (error) {\r\n      const duration = performance.now() - startTime;\r\n      logger.error('Restore operation failed', {\r\n        backupId,\r\n        error: error.message,\r\n        duration: Math.round(duration)\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        error: error.message,\r\n        duration\r\n      };\r\n    }\r\n  }\r\n\r\n  async performRestore(backupData, selectiveRestore) {\r\n    const { metadata, localStorage: lsData, sessionStorage: ssData, indexedDB, cache } = backupData;\r\n\r\n    // Restore localStorage\r\n    if ((!selectiveRestore || selectiveRestore.includes('localStorage')) && lsData) {\r\n      Object.entries(lsData).forEach(([key, value]) => {\r\n        if (value !== null) {\r\n          localStorage.setItem(key, value);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Restore sessionStorage\r\n    if ((!selectiveRestore || selectiveRestore.includes('sessionStorage')) && ssData) {\r\n      Object.entries(ssData).forEach(([key, value]) => {\r\n        if (value !== null) {\r\n          sessionStorage.setItem(key, value);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Restore IndexedDB\r\n    if ((!selectiveRestore || selectiveRestore.includes('indexedDB')) && indexedDB) {\r\n      await this.restoreIndexedDB(indexedDB);\r\n    }\r\n\r\n    // Restore cache\r\n    if ((!selectiveRestore || selectiveRestore.includes('cache')) && cache) {\r\n      await this.restoreCache(cache);\r\n    }\r\n\r\n    logger.info('Data restoration completed', {\r\n      restoredSections: selectiveRestore || ['all']\r\n    });\r\n  }\r\n\r\n  async backupLocalStorage() {\r\n    const data = {};\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      data[key] = localStorage.getItem(key);\r\n    }\r\n    return data;\r\n  }\r\n\r\n  async backupSessionStorage() {\r\n    const data = {};\r\n    for (let i = 0; i < sessionStorage.length; i++) {\r\n      const key = sessionStorage.key(i);\r\n      data[key] = sessionStorage.getItem(key);\r\n    }\r\n    return data;\r\n  }\r\n\r\n  async backupIndexedDB() {\r\n    try {\r\n      // Backup cache database\r\n      const cacheKeys = await cacheManager.keys('*');\r\n      const cacheData = {};\r\n\r\n      for (const key of cacheKeys) {\r\n        cacheData[key] = await cacheManager.get(key);\r\n      }\r\n\r\n      return cacheData;\r\n    } catch (error) {\r\n      logger.warn('IndexedDB backup failed', { error: error.message });\r\n      return {};\r\n    }\r\n  }\r\n\r\n  async backupCacheData() {\r\n    try {\r\n      return await cacheManager.getStats();\r\n    } catch (error) {\r\n      logger.warn('Cache backup failed', { error: error.message });\r\n      return {};\r\n    }\r\n  }\r\n\r\n  async backupUserSettings() {\r\n    return {\r\n      theme: localStorage.getItem('theme'),\r\n      language: localStorage.getItem('language'),\r\n      preferences: localStorage.getItem('userPreferences'),\r\n      settings: localStorage.getItem('appSettings')\r\n    };\r\n  }\r\n\r\n  async backupCalculations() {\r\n    try {\r\n      const calculationKeys = await cacheManager.keys('calculation:*');\r\n      const calculations = {};\r\n\r\n      for (const key of calculationKeys) {\r\n        calculations[key] = await cacheManager.get(key);\r\n      }\r\n\r\n      return calculations;\r\n    } catch (error) {\r\n      logger.warn('Calculations backup failed', { error: error.message });\r\n      return {};\r\n    }\r\n  }\r\n\r\n  async restoreIndexedDB(indexedDBData) {\r\n    try {\r\n      for (const [key, value] of Object.entries(indexedDBData)) {\r\n        await cacheManager.set(key, value, { ttl: 24 * 60 * 60 * 1000 });\r\n      }\r\n    } catch (error) {\r\n      logger.error('IndexedDB restore failed', { error: error.message });\r\n    }\r\n  }\r\n\r\n  async restoreCache(cacheData) {\r\n    try {\r\n      // Cache stats are informational only, no restoration needed\r\n      logger.info('Cache stats from backup', cacheData);\r\n    } catch (error) {\r\n      logger.error('Cache restore failed', { error: error.message });\r\n    }\r\n  }\r\n\r\n  shouldCompress(data) {\r\n    return data.length > this.compressionThreshold;\r\n  }\r\n\r\n  compressData(data) {\r\n    try {\r\n      return {\r\n        compressed: true,\r\n        data: JSON.stringify(data) // Simple JSON compression\r\n      };\r\n    } catch (error) {\r\n      logger.warn('Compression failed', { error: error.message });\r\n      return data;\r\n    }\r\n  }\r\n\r\n  decompressData(compressedData) {\r\n    try {\r\n      if (compressedData.compressed) {\r\n        return JSON.parse(compressedData.data);\r\n      }\r\n      return compressedData;\r\n    } catch (error) {\r\n      logger.error('Decompression failed', { error: error.message });\r\n      return compressedData;\r\n    }\r\n  }\r\n\r\n  calculateChecksum(data) {\r\n    let hash = 0;\r\n    for (let i = 0; i < data.length; i++) {\r\n      const char = data.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash;\r\n    }\r\n    return hash.toString(16);\r\n  }\r\n\r\n  async validateBackupIntegrity(backupData) {\r\n    try {\r\n      if (!backupData.metadata) {\r\n        logger.warn('Backup missing metadata');\r\n        return false;\r\n      }\r\n\r\n      const { checksum, size } = backupData.metadata;\r\n      const currentData = JSON.stringify(backupData);\r\n\r\n      if (size && currentData.length !== size) {\r\n        logger.warn('Backup size mismatch', {\r\n          expected: size,\r\n          actual: currentData.length\r\n        });\r\n      }\r\n\r\n      if (checksum) {\r\n        const currentChecksum = this.calculateChecksum(currentData);\r\n        if (currentChecksum !== checksum) {\r\n          logger.error('Backup checksum validation failed', {\r\n            expected: checksum,\r\n            actual: currentChecksum\r\n          });\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      logger.error('Backup validation failed', { error: error.message });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async storeBackup(key, data) {\r\n    await cacheManager.set(key, data, {\r\n      ttl: 30 * 24 * 60 * 60 * 1000, // 30 days\r\n      tags: ['backup']\r\n    });\r\n  }\r\n\r\n  async retrieveBackup(key) {\r\n    return await cacheManager.get(key);\r\n  }\r\n\r\n  async updateBackupRegistry(backupId, metadata) {\r\n    try {\r\n      const registry = await cacheManager.get('backup_registry') || {};\r\n      registry[backupId] = metadata;\r\n\r\n      await cacheManager.set('backup_registry', registry, {\r\n        ttl: 30 * 24 * 60 * 60 * 1000,\r\n        tags: ['backup', 'registry']\r\n      });\r\n    } catch (error) {\r\n      logger.error('Failed to update backup registry', { error: error.message });\r\n    }\r\n  }\r\n\r\n  async getBackupList() {\r\n    try {\r\n      const registry = await cacheManager.get('backup_registry') || {};\r\n      return Object.entries(registry)\r\n        .map(([id, metadata]) => ({ id, ...metadata }))\r\n        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));\r\n    } catch (error) {\r\n      logger.error('Failed to get backup list', { error: error.message });\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async deleteBackup(backupId) {\r\n    try {\r\n      const backupKey = `${this.backupPrefix}${backupId}`;\r\n      await cacheManager.delete(backupKey);\r\n\r\n      const registry = await cacheManager.get('backup_registry') || {};\r\n      delete registry[backupId];\r\n      await cacheManager.set('backup_registry', registry);\r\n\r\n      logger.info('Backup deleted', { backupId });\r\n      return { success: true };\r\n    } catch (error) {\r\n      logger.error('Failed to delete backup', { backupId, error: error.message });\r\n      return { success: false, error: error.message };\r\n    }\r\n  }\r\n\r\n  async cleanupOldBackups() {\r\n    try {\r\n      const backups = await this.getBackupList();\r\n      const backupsToDelete = backups.slice(this.maxBackups);\r\n\r\n      for (const backup of backupsToDelete) {\r\n        await this.deleteBackup(backup.id);\r\n      }\r\n\r\n      logger.info('Backup cleanup completed', {\r\n        totalBackups: backups.length,\r\n        deletedBackups: backupsToDelete.length,\r\n        remainingBackups: Math.min(backups.length, this.maxBackups)\r\n      });\r\n\r\n      return backupsToDelete.length;\r\n    } catch (error) {\r\n      logger.error('Backup cleanup failed', { error: error.message });\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  async getSystemHealth() {\r\n    try {\r\n      const backups = await this.getBackupList();\r\n      const lastBackup = backups[0];\r\n      const backupStats = await cacheManager.getStats();\r\n\r\n      return {\r\n        totalBackups: backups.length,\r\n        lastBackup: lastBackup ? {\r\n          id: lastBackup.id,\r\n          timestamp: lastBackup.timestamp,\r\n          type: lastBackup.type,\r\n          size: lastBackup.size\r\n        } : null,\r\n        autoBackupEnabled: !!this.autoBackupInterval,\r\n        nextAutoBackup: this.getNextBackupTime(),\r\n        storageHealth: backupStats,\r\n        encryptionEnabled: this.encryptionEnabled\r\n      };\r\n    } catch (error) {\r\n      logger.error('Failed to get system health', { error: error.message });\r\n      return { error: error.message };\r\n    }\r\n  }\r\n\r\n  getNextBackupTime() {\r\n    // Calculate next auto backup time\r\n    const now = Date.now();\r\n    const lastAutoBackupTime = this.lastAutoBackupTime || now;\r\n    return new Date(lastAutoBackupTime + this.autoBackupInterval).toISOString();\r\n  }\r\n\r\n  destroy() {\r\n    if (this.incrementalTimeout) {\r\n      clearTimeout(this.incrementalTimeout);\r\n    }\r\n    logger.info('Backup and Recovery System destroyed');\r\n  }\r\n}\r\n\r\nconst backupRecoverySystem = new BackupRecoverySystem();\r\n\r\nexport default backupRecoverySystem;\r\nexport { BackupRecoverySystem };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}