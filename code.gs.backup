// ============================================================================
// Bhotch CRM - Google Apps Script Backend (Code.gs)
// CLEAN VERSION - Complete Job Count & Lead Management System
// ============================================================================

/**
 * @fileoverview Clean, production-ready backend API for CRM application
 * with complete CRUD operations for both leads and job counts.
 */

// --- CONFIGURATION ---
const SPREADSHEET_ID = '1E9VX7XI7GNGJa8Hq9__XAWv95WNgfJto1gUEXMbGqi0';
const LEADS_SHEET_NAME = 'Bhotchleads';
const JOB_COUNT_SHEET_NAME = 'Job Count';

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function createResponse(data, success = true, message = '') {
  const response = {
    success: success,
    message: message,
    timestamp: new Date().toISOString(),
    ...data
  };
  return ContentService
    .createTextOutput(JSON.stringify(response))
    .setMimeType(ContentService.MimeType.JSON);
}

function logMessage(message, level = 'INFO') {
  console.log(`[${new Date().toISOString()}] [${level}] ${message}`);
}

function getSheetSafely(sheetName) {
  try {
    const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = spreadsheet.getSheetByName(sheetName);
    if (!sheet) {
      throw new Error(`Sheet "${sheetName}" not found in spreadsheet`);
    }
    return sheet;
  } catch (error) {
    throw new Error(`Failed to access sheet "${sheetName}": ${error.message}`);
  }
}

// ============================================================================
// WEB APP ENTRY POINTS
// ============================================================================

function doGet(e) {
  logMessage(`GET request received: ${JSON.stringify(e.parameter)}`);
  try {
    const action = e.parameter.action;
    switch (action) {
      case 'getLeads':
        return getLeads();
      case 'getJobCounts':
        return getJobCounts();
      case 'testConnection':
        return testConnection();
      default:
        return createResponse({}, false, `Unknown GET action: ${action}`);
    }
  } catch (error) {
    logMessage(`GET Error: ${error.toString()}`, 'ERROR');
    return createResponse({}, false, `Server Error: ${error.message}`);
  }
}

function doPost(e) {
  logMessage('POST request received');
  try {
    const requestData = JSON.parse(e.postData.contents);
    const action = requestData.action;

    logMessage(`Executing action: ${action}`);

    switch (action) {
      // Lead operations
      case 'getLeads':
        return getLeads();
      case 'addLead':
        return addLead(requestData.lead);
      case 'updateLead':
        return updateLead(requestData.lead);
      case 'deleteLead':
        return deleteLead(requestData.leadId);

      // Job Count operations
      case 'getJobCounts':
        return getJobCounts();
      case 'addJobCount':
        return addJobCount(requestData.jobCount);
      case 'updateJobCount':
        return updateJobCount(requestData.jobCount);
      case 'deleteJobCount':
        return deleteJobCount(requestData.jobCountId);

      // Utility operations
      case 'testConnection':
        return testConnection();
      case 'geocodeAddress':
        return geocodeAddress(requestData.address);

      default:
        return createResponse({}, false, `Unknown POST action: ${action}`);
    }
  } catch (error) {
    logMessage(`POST Error: ${error.toString()}`, 'ERROR');
    return createResponse({}, false, `Server Error: ${error.message}`);
  }
}

// ============================================================================
// UTILITY OPERATIONS
// ============================================================================

function testConnection() {
  logMessage('Testing connection to Google Sheets');
  try {
    const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
    const leadsSheet = spreadsheet.getSheetByName(LEADS_SHEET_NAME);
    const jobCountSheet = spreadsheet.getSheetByName(JOB_COUNT_SHEET_NAME);

    const connectionStatus = {
      spreadsheetId: SPREADSHEET_ID,
      leadsSheet: {
        exists: !!leadsSheet,
        name: LEADS_SHEET_NAME,
        rowCount: leadsSheet ? leadsSheet.getLastRow() : 0
      },
      jobCountSheet: {
        exists: !!jobCountSheet,
        name: JOB_COUNT_SHEET_NAME,
        rowCount: jobCountSheet ? jobCountSheet.getLastRow() : 0
      }
    };

    logMessage(`Connection test successful: ${JSON.stringify(connectionStatus)}`);
    return createResponse(connectionStatus, true, 'Connection successful');
  } catch (error) {
    logMessage(`Connection test failed: ${error.toString()}`, 'ERROR');
    return createResponse({}, false, `Connection failed: ${error.message}`);
  }
}

function geocodeAddress(address) {
  if (!address) {
    return createResponse({}, false, 'Address parameter is required');
  }

  logMessage(`Geocoding address: ${address}`);
  try {
    const geocoder = Maps.newGeocoder().setRegion('US');
    const response = geocoder.geocode(address);

    if (response.status !== 'OK') {
      throw new Error(`Geocoding failed. Status: ${response.status}`);
    }

    const location = response.results[0].geometry.location;
    const coords = { latitude: location.lat, longitude: location.lng };

    logMessage(`Geocoding successful: ${JSON.stringify(coords)}`);
    return createResponse(coords, true, 'Address geocoded successfully');
  } catch (error) {
    logMessage(`Geocoding Error: ${error.toString()}`, 'ERROR');
    return createResponse({}, false, `Failed to geocode address: ${error.message}`);
  }
}

// ============================================================================
// LEAD OPERATIONS
// ============================================================================

function getLeads() {
  try {
    const sheet = getSheetSafely(LEADS_SHEET_NAME);
    const lastRow = sheet.getLastRow();

    if (lastRow <= 1) {
      return createResponse({ data: [], count: 0 }, true, 'No leads found');
    }

    const range = sheet.getDataRange();
    const values = range.getValues();
    const headers = values[0].map(h => String(h).trim());
    const dataRows = values.slice(1);

    const leads = dataRows.map(row => {
      const lead = {};
      headers.forEach((header, index) => {
        if (header) {
          const value = row[index];
          lead[header] = value instanceof Date ? value.toISOString() : value;
        }
      });
      return lead;
    });

    logMessage(`Successfully retrieved ${leads.length} leads`);
    return createResponse({ data: leads, count: leads.length }, true, `Retrieved ${leads.length} leads`);
  } catch (error) {
    logMessage(`getLeads Error: ${error.toString()}`, 'ERROR');
    return createResponse({ data: [] }, false, `Failed to fetch leads: ${error.message}`);
  }
}

function addLead(leadData) {
  try {
    if (!leadData || typeof leadData !== 'object') {
      throw new Error('Invalid lead data provided');
    }

    const sheet = getSheetSafely(LEADS_SHEET_NAME);
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];

    // Add metadata
    leadData.id = `lead_${Date.now()}`;
    leadData.createdDate = new Date().toISOString();
    leadData.status = leadData.status || 'new';

    const rowData = headers.map(header => leadData[header] || '');
    sheet.appendRow(rowData);

    logMessage(`Successfully added lead ID: ${leadData.id}`);
    return createResponse({ lead: leadData }, true, 'Lead added successfully');
  } catch (error) {
    logMessage(`addLead Error: ${error.toString()}`, 'ERROR');
    return createResponse({}, false, `Failed to add lead: ${error.message}`);
  }
}

function updateLead(leadData) {
  try {
    if (!leadData || !leadData.id) {
      throw new Error('Lead data with valid ID is required for updates');
    }

    const sheet = getSheetSafely(LEADS_SHEET_NAME);
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const idColumnIndex = headers.indexOf('id');

    if (idColumnIndex === -1) {
      throw new Error("'id' column not found in sheet");
    }

    const rowIndex = data.slice(1).findIndex(row => row[idColumnIndex] == leadData.id) + 2;
    if (rowIndex < 2) {
      throw new Error(`Lead with ID ${leadData.id} not found`);
    }

    leadData.modifiedDate = new Date().toISOString();
    const rowData = headers.map(header =>
      leadData[header] !== undefined ? leadData[header] :
      sheet.getRange(rowIndex, headers.indexOf(header) + 1).getValue()
    );

    sheet.getRange(rowIndex, 1, 1, headers.length).setValues([rowData]);

    logMessage(`Successfully updated lead ID: ${leadData.id}`);
    return createResponse({ lead: leadData }, true, 'Lead updated successfully');
  } catch (error) {
    logMessage(`updateLead Error: ${error.toString()}`, 'ERROR');
    return createResponse({}, false, `Failed to update lead: ${error.message}`);
  }
}

function deleteLead(leadId) {
  try {
    if (!leadId) {
      throw new Error('Lead ID is required for deletion');
    }

    const sheet = getSheetSafely(LEADS_SHEET_NAME);
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const idColumnIndex = headers.indexOf('id');

    if (idColumnIndex === -1) {
      throw new Error("'id' column not found in sheet");
    }

    const rowIndex = data.slice(1).findIndex(row => row[idColumnIndex] == leadId) + 2;
    if (rowIndex < 2) {
      throw new Error(`Lead with ID ${leadId} not found`);
    }

    sheet.deleteRow(rowIndex);

    logMessage(`Successfully deleted lead ID: ${leadId}`);
    return createResponse({ deletedId: leadId }, true, 'Lead deleted successfully');
  } catch (error) {
    logMessage(`deleteLead Error: ${error.toString()}`, 'ERROR');
    return createResponse({}, false, `Failed to delete lead: ${error.message}`);
  }
}

// ============================================================================
// JOB COUNT OPERATIONS
// ============================================================================

function getJobCounts() {
  try {
    const sheet = getSheetSafely(JOB_COUNT_SHEET_NAME);
    const lastRow = sheet.getLastRow();

    if (lastRow <= 1) {
      return createResponse({ data: [], count: 0 }, true, 'No job counts found');
    }

    const range = sheet.getDataRange();
    const values = range.getValues();
    const headers = values[0].map(h => String(h).trim());
    const dataRows = values.slice(1);

    const jobCounts = dataRows.map((row, index) => {
      const jobCount = {};
      headers.forEach((header, columnIndex) => {
        if (header) {
          const value = row[columnIndex];
          const camelCaseHeader = convertToCamelCase(header);
          jobCount[camelCaseHeader] = value instanceof Date ? value.toISOString() : value;
        }
      });

      // Ensure we have an ID field
      if (!jobCount.id) {
        jobCount.id = `jobcount_${Date.now()}_${index}`;
      }

      return jobCount;
    });

    logMessage(`Successfully retrieved ${jobCounts.length} job counts`);
    return createResponse({ data: jobCounts, count: jobCounts.length }, true, `Retrieved ${jobCounts.length} job counts`);
  } catch (error) {
    logMessage(`getJobCounts Error: ${error.toString()}`, 'ERROR');
    return createResponse({ data: [] }, false, `Failed to fetch job counts: ${error.message}`);
  }
}

function addJobCount(jobCountData) {
  try {
    if (!jobCountData || typeof jobCountData !== 'object') {
      throw new Error('Invalid job count data provided');
    }

    const sheet = getSheetSafely(JOB_COUNT_SHEET_NAME);
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];

    // Add metadata
    jobCountData.id = `jobcount_${Date.now()}`;
    jobCountData.createdDate = new Date().toISOString();

    // Map camelCase frontend fields to sheet headers
    const rowData = headers.map(header => {
      const camelCaseHeader = convertToCamelCase(header);
      return jobCountData[camelCaseHeader] || '';
    });

    sheet.appendRow(rowData);

    logMessage(`Successfully added job count ID: ${jobCountData.id}`);
    return createResponse({ jobCount: jobCountData }, true, 'Job count added successfully');
  } catch (error) {
    logMessage(`addJobCount Error: ${error.toString()}`, 'ERROR');
    return createResponse({}, false, `Failed to add job count: ${error.message}`);
  }
}

function updateJobCount(jobCountData) {
  try {
    if (!jobCountData || !jobCountData.id) {
      throw new Error('Job count data with valid ID is required for updates');
    }

    const sheet = getSheetSafely(JOB_COUNT_SHEET_NAME);
    const data = sheet.getDataRange().getValues();
    const headers = data[0];

    // Find ID column or use name/date combination
    let idColumnIndex = headers.findIndex(h => h.toLowerCase().trim() === 'id');
    let rowIndex;

    if (idColumnIndex !== -1) {
      rowIndex = data.slice(1).findIndex(row => row[idColumnIndex] == jobCountData.id) + 2;
    } else {
      // Fallback to firstname/lastname/date matching
      const firstNameIndex = headers.findIndex(h => h.toLowerCase().includes('first'));
      const lastNameIndex = headers.findIndex(h => h.toLowerCase().includes('last'));
      const dateIndex = headers.findIndex(h => h.toLowerCase().includes('date'));

      if (firstNameIndex !== -1 && dateIndex !== -1) {
        rowIndex = data.slice(1).findIndex(row =>
          row[firstNameIndex] == jobCountData.firstName &&
          (row[lastNameIndex] == jobCountData.lastName || !jobCountData.lastName) &&
          (row[dateIndex] == jobCountData.date ||
           new Date(row[dateIndex]).toISOString().split('T')[0] == jobCountData.date)
        ) + 2;
      }
    }

    if (!rowIndex || rowIndex < 2) {
      throw new Error('Job count not found for update');
    }

    jobCountData.modifiedDate = new Date().toISOString();

    const rowData = headers.map(header => {
      const camelCaseHeader = convertToCamelCase(header);
      return jobCountData[camelCaseHeader] !== undefined ?
        jobCountData[camelCaseHeader] :
        sheet.getRange(rowIndex, headers.indexOf(header) + 1).getValue();
    });

    sheet.getRange(rowIndex, 1, 1, headers.length).setValues([rowData]);

    logMessage(`Successfully updated job count ID: ${jobCountData.id}`);
    return createResponse({ jobCount: jobCountData }, true, 'Job count updated successfully');
  } catch (error) {
    logMessage(`updateJobCount Error: ${error.toString()}`, 'ERROR');
    return createResponse({}, false, `Failed to update job count: ${error.message}`);
  }
}

function deleteJobCount(jobCountId) {
  try {
    if (!jobCountId) {
      throw new Error('Job count ID is required for deletion');
    }

    const sheet = getSheetSafely(JOB_COUNT_SHEET_NAME);
    const data = sheet.getDataRange().getValues();
    const headers = data[0];

    const idColumnIndex = headers.findIndex(h => h.toLowerCase().trim() === 'id');
    if (idColumnIndex === -1) {
      throw new Error("'id' column not found in job count sheet");
    }

    const rowIndex = data.slice(1).findIndex(row => row[idColumnIndex] == jobCountId) + 2;
    if (rowIndex < 2) {
      throw new Error(`Job count with ID ${jobCountId} not found`);
    }

    sheet.deleteRow(rowIndex);

    logMessage(`Successfully deleted job count ID: ${jobCountId}`);
    return createResponse({ deletedId: jobCountId }, true, 'Job count deleted successfully');
  } catch (error) {
    logMessage(`deleteJobCount Error: ${error.toString()}`, 'ERROR');
    return createResponse({}, false, `Failed to delete job count: ${error.message}`);
  }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Test database connection
 */
function testConnection() {
    try {
      logMessage(`Starting vent calculation for ${sqft} sqft`);

      // Primary: Web automation approach
      const webResult = this.calculateViaWebAutomation(sqft, options);
      if (webResult.success) {
        logMessage('Web automation successful');
        return webResult;
      }

      logMessage('Web automation failed, using mathematical fallback');

      // Secondary: Mathematical fallback
      const mathResult = this.calculateViaMathematicalFormulas(sqft, options);
      if (mathResult.success) {
        logMessage('Mathematical calculation successful');
        return mathResult;
      }

      logMessage('All calculation methods failed');
      return createResponse({}, false, 'All calculation methods failed. Manual entry required.');

    } catch (error) {
      logMessage(`Vent calculation error: ${error.toString()}`, 'ERROR');
      return createResponse({}, false, `Calculation failed: ${error.message}`);
    }
  }

  /**
   * Web automation approach using UrlFetchApp
   */
  calculateViaWebAutomation(sqft, options = {}) {
    try {
      for (let attempt = 1; attempt <= this.retryAttempts; attempt++) {
        try {
          logMessage(`Web automation attempt ${attempt} for ${sqft} sqft`);

          // Step 1: Get initial page to establish session
          const sessionResponse = UrlFetchApp.fetch(this.baseUrl, {
            method: 'GET',
            followRedirects: true,
            muteHttpExceptions: true,
            headers: {
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
          });

          if (sessionResponse.getResponseCode() !== 200) {
            throw new Error(`Session setup failed: ${sessionResponse.getResponseCode()}`);
          }

          // Step 2: Submit calculation request
          const calculationPayload = {
            'attic_floor_space': sqft.toString(),
            'exhaust_system': 'ridge_vent',
            'roof_slope': '4'
          };

          const calculationResponse = UrlFetchApp.fetch(this.baseUrl, {
            method: 'POST',
            payload: calculationPayload,
            followRedirects: true,
            muteHttpExceptions: true,
            headers: {
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
              'Content-Type': 'application/x-www-form-urlencoded',
              'X-Requested-With': 'XMLHttpRequest'
            }
          });

          if (calculationResponse.getResponseCode() !== 200) {
            throw new Error(`Calculation request failed: ${calculationResponse.getResponseCode()}`);
          }

          const responseText = calculationResponse.getContentText();
          const results = this.parseLomacoResponse(responseText, sqft);

          if (results.success) {
            return createResponse({
              ventCalculations: results.data,
              calculationMethod: 'web_automation',
              timestamp: new Date().toISOString()
            }, true, 'Lomanco calculation completed successfully');
          } else {
            throw new Error('Failed to parse Lomanco response');
          }

        } catch (attemptError) {
          logMessage(`Attempt ${attempt} failed: ${attemptError.message}`, 'WARN');
          if (attempt < this.retryAttempts) {
            Utilities.sleep(this.retryDelay * attempt);
          } else {
            throw attemptError;
          }
        }
      }
    } catch (error) {
      logMessage(`Web automation failed: ${error.toString()}`, 'ERROR');
      return { success: false, message: error.message };
    }
  }

  /**
   * Parse Lomanco website response to extract vent values
   */
  parseLomacoResponse(htmlContent, sqft) {
    try {
      let ridgeVents = 0;
      let turbineVents = 0;
      let rimeFlow = 0;

      // Extract DA-4 Ridge Vent values
      const ridgeVentRegex = /DA-4[^0-9]*(\d+)/gi;
      const ridgeMatches = htmlContent.match(ridgeVentRegex);
      if (ridgeMatches && ridgeMatches.length > 0) {
        const numbers = ridgeMatches[0].match(/\d+/);
        if (numbers) ridgeVents = parseInt(numbers[0]);
      }

      // Extract ALL-14" Turbine values
      const turbineRegex = /ALL-14["\s]*[^0-9]*(\d+)/gi;
      const turbineMatches = htmlContent.match(turbineRegex);
      if (turbineMatches && turbineMatches.length > 0) {
        const numbers = turbineMatches[0].match(/\d+/);
        if (numbers) turbineVents = parseInt(numbers[0]);
      }

      // Extract Rime Flow values (typically between ridge vent calculations)
      const rimeFlowRegex = /(?:rime|flow)[^0-9]*(\d+(?:\.\d+)?)/gi;
      const rimeMatches = htmlContent.match(rimeFlowRegex);
      if (rimeMatches && rimeMatches.length > 0) {
        const numbers = rimeMatches[0].match(/\d+(?:\.\d+)?/);
        if (numbers) rimeFlow = parseFloat(numbers[0]);
      }

      // Validate results
      if (ridgeVents > 0 || turbineVents > 0) {
        return {
          success: true,
          data: {
            ridgeVents: ridgeVents,
            turbineVents: turbineVents,
            rimeFlow: rimeFlow,
            sqft: sqft,
            source: 'lomanco_web'
          }
        };
      }

      return { success: false, message: 'No valid vent calculations found in response' };

    } catch (error) {
      logMessage(`Response parsing error: ${error.toString()}`, 'ERROR');
      return { success: false, message: `Failed to parse response: ${error.message}` };
    }
  }

  /**
   * Mathematical fallback calculation based on industry standards
   */
  calculateViaMathematicalFormulas(sqft, options = {}) {
    try {
      logMessage(`Calculating vents using mathematical formulas for ${sqft} sqft`);

      // Industry standard: 1 sq ft of ventilation per 300 sq ft of attic space
      const requiredVentilationSqFt = sqft / 300;

      // Ridge vent calculations (DA-4 specifications)
      // DA-4: ~18 sq in of Net Free Area per linear foot
      const da4NfaPerFoot = 18; // sq inches per linear foot
      const requiredVentilationSqIn = requiredVentilationSqFt * 144; // convert to sq inches
      const ridgeVentsLinearFt = Math.ceil(requiredVentilationSqIn / da4NfaPerFoot);

      // Turbine vent calculations (ALL-14" specifications)
      // ALL-14": ~130-150 sq in effective area
      const all14EffectiveArea = 140; // sq inches per turbine
      const turbineVentsCount = Math.ceil(requiredVentilationSqIn / all14EffectiveArea);

      // Rime flow calculation (CFM estimate)
      // Standard: ~0.75 CFM per sq ft of attic space
      const rimeFlowCfm = Math.round(sqft * 0.75 * 100) / 100;

      const calculations = {
        ridgeVents: ridgeVentsLinearFt,
        turbineVents: turbineVentsCount,
        rimeFlow: rimeFlowCfm,
        sqft: sqft,
        source: 'mathematical_formula'
      };

      logMessage(`Mathematical calculation complete: ${JSON.stringify(calculations)}`);

      return createResponse({
        ventCalculations: calculations,
        calculationMethod: 'mathematical_fallback',
        timestamp: new Date().toISOString()
      }, true, 'Mathematical calculation completed successfully');

    } catch (error) {
      logMessage(`Mathematical calculation error: ${error.toString()}`, 'ERROR');
      return { success: false, message: `Mathematical calculation failed: ${error.message}` };
    }
  }
}

/**
 * Main vent calculation endpoint
 */
function calculateLomacoVents(sqft, options = {}) {
  try {
    if (!sqft || isNaN(sqft) || sqft <= 0) {
      return createResponse({}, false, 'Valid SQFT value is required');
    }

    const calculator = new LomacoVentCalculationService();
    return calculator.calculateVentRequirements(parseFloat(sqft), options);

  } catch (error) {
    logMessage(`calculateLomacoVents Error: ${error.toString()}`, 'ERROR');
    return createResponse({}, false, `Vent calculation failed: ${error.message}`);
  }
}

/**
 * Batch process multiple job counts for vent calculations
 */
function batchCalculateVents(jobCountIds = []) {
  try {
    const sheet = getSheetSafely(JOB_COUNT_SHEET_NAME);
    const data = sheet.getDataRange().getValues();
    const headers = data[0];

    const sqftIndex = headers.findIndex(h => h.toLowerCase().includes('sq ft'));
    const ridgeVentsIndex = headers.findIndex(h => h.toLowerCase().includes('ridge vents'));
    const turbineIndex = headers.findIndex(h => h.toLowerCase().includes('turbine'));
    const rimeFlowIndex = headers.findIndex(h => h.toLowerCase().includes('rime flow'));

    if (sqftIndex === -1) {
      return createResponse({}, false, 'SQFT column not found in Job Count sheet');
    }

    let processedCount = 0;
    let errorCount = 0;
    const results = [];

    // Process each row
    for (let i = 1; i < data.length; i++) {
      try {
        const row = data[i];
        const sqft = parseFloat(row[sqftIndex]);

        if (!isNaN(sqft) && sqft > 0) {
          const calculation = calculateLomacoVents(sqft);

          if (calculation.success) {
            const vents = calculation.ventCalculations;

            // Update the sheet with calculated values
            if (ridgeVentsIndex !== -1) {
              sheet.getRange(i + 1, ridgeVentsIndex + 1).setValue(vents.ridgeVents);
            }
            if (turbineIndex !== -1) {
              sheet.getRange(i + 1, turbineIndex + 1).setValue(vents.turbineVents);
            }
            if (rimeFlowIndex !== -1) {
              sheet.getRange(i + 1, rimeFlowIndex + 1).setValue(vents.rimeFlow);
            }

            processedCount++;
            results.push({
              row: i + 1,
              sqft: sqft,
              calculations: vents,
              success: true
            });
          } else {
            errorCount++;
            results.push({
              row: i + 1,
              sqft: sqft,
              error: calculation.message,
              success: false
            });
          }
        }
      } catch (rowError) {
        errorCount++;
        logMessage(`Error processing row ${i + 1}: ${rowError.toString()}`, 'ERROR');
      }
    }

    return createResponse({
      processedCount: processedCount,
      errorCount: errorCount,
      results: results
    }, true, `Batch calculation complete: ${processedCount} processed, ${errorCount} errors`);

  } catch (error) {
    logMessage(`Batch calculation error: ${error.toString()}`, 'ERROR');
    return createResponse({}, false, `Batch calculation failed: ${error.message}`);
  }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Converts sheet header names to camelCase for frontend compatibility
 */
function convertToCamelCase(headerName) {
  if (!headerName) return '';

  const specialCases = {
    // Customer Information
    'First Name': 'firstName',
    'Last Name': 'lastName',
    'Customer Name': 'customerName',
    'Full Name': 'customerName',
    'Phone Number': 'phoneNumber',
    'Phone': 'phoneNumber',
    'Email': 'email',
    'Address': 'address',

    // Job Information
    'Lead Source': 'leadSource',
    'Quality': 'quality',
    'Disposition': 'disposition',
    'Roof Age': 'roofAge',
    'Roof Type': 'roofType',
    'Quote Amount': 'dabellaQuote',
    'DaBella Quote': 'dabellaQuote',
    'Notes': 'notes',

    // Job Count Measurements
    'Date': 'date',
    'SQ FT': 'sqFt',
    'Ridge LF': 'ridgeLf',
    'Valley LF': 'valleyLf',
    'Eaves LF': 'eavesLf',
    'Ridge Vents': 'ridgeVents',
    'Turbine': 'turbine',
    'Rime Flow': 'rimeFlow',
    'High Profile Ridge Cap': 'highProfileRidgeCap',
    'Valley Metal': 'valleyMetal',
    'Pipes [1 1/2"]': 'pipes1Half',
    'Pipes [2"]': 'pipes2',
    'Pipes [3"]': 'pipes3',
    'Pipes [4\']': 'pipes4',
    'Pipes [4"]': 'pipes4',
    'Gables': 'gables',
    'Turtle Backs': 'turtleBacks',
    'Satellite': 'satellite',
    'Chimney': 'chimney',
    'Solar': 'solar',
    'Swamp Cooler': 'swampCooler',
    'Gutters LF': 'guttersLf',
    'Downspouts': 'downspouts',
    'Gutter Guard LF': 'gutterGuardLf',
    'Permanent Lighting': 'permanentLighting',

    // System fields
    'ID': 'id',
    'Created Date': 'createdDate',
    'Modified Date': 'modifiedDate'
  };

  return specialCases[headerName] || headerName
    .replace(/[\[\]"']/g, '')
    .split(/\s+/)
    .map((word, index) => {
      if (index === 0) return word.toLowerCase();
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    })
    .join('');
}