{"ast":null,"code":"import Dexie from 'dexie';\nclass AdvancedCacheManager {\n  constructor() {\n    this.db = new Dexie('UltimateCRMCache');\n    this.initializeDatabase();\n    this.initializeInMemoryCache();\n  }\n  initializeDatabase() {\n    this.db.version(1).stores({\n      cache: '++id, key, value, expiresAt, createdAt, accessCount, lastAccessed, tags',\n      sessions: '++id, sessionId, data, expiresAt, createdAt',\n      calculations: '++id, sqft, ridgeVents, turbineVents, rimeFlow, method, timestamp',\n      metrics: '++id, operation, duration, success, timestamp, metadata'\n    });\n    this.db.open().catch(err => {\n      console.error('Failed to open cache database:', err);\n    });\n  }\n  initializeInMemoryCache() {\n    this.memoryCache = new Map();\n    this.cacheStats = {\n      hits: 0,\n      misses: 0,\n      sets: 0,\n      deletes: 0,\n      evictions: 0\n    };\n    this.maxMemorySize = 1000;\n    this.cleanupInterval = setInterval(() => this.cleanup(), 300000);\n  }\n  async set(key, value, options = {}) {\n    const {\n      ttl = 3600000,\n      // 1 hour default\n      tags = [],\n      priority = 1,\n      compress = false\n    } = options;\n    const now = Date.now();\n    const expiresAt = now + ttl;\n    const cacheEntry = {\n      key,\n      value: compress ? this.compress(value) : value,\n      expiresAt,\n      createdAt: now,\n      accessCount: 0,\n      lastAccessed: now,\n      tags: Array.isArray(tags) ? tags : [tags],\n      priority,\n      compressed: compress\n    };\n    try {\n      // Store in memory cache for fast access\n      this.memoryCache.set(key, cacheEntry);\n      this.enforceMemoryLimit();\n\n      // Store in persistent database\n      await this.db.cache.put(cacheEntry);\n      this.cacheStats.sets++;\n      return true;\n    } catch (error) {\n      console.error('Cache set error:', error);\n      return false;\n    }\n  }\n  async get(key) {\n    const startTime = performance.now();\n    try {\n      // Check memory cache first\n      let entry = this.memoryCache.get(key);\n\n      // If not in memory, check database\n      if (!entry) {\n        const dbEntry = await this.db.cache.where('key').equals(key).first();\n        if (dbEntry) {\n          entry = dbEntry;\n          // Add to memory cache for future access\n          this.memoryCache.set(key, entry);\n        }\n      }\n      if (!entry) {\n        this.cacheStats.misses++;\n        this.recordMetric('cache_get', performance.now() - startTime, false);\n        return null;\n      }\n\n      // Check expiration\n      if (Date.now() > entry.expiresAt) {\n        await this.delete(key);\n        this.cacheStats.misses++;\n        this.recordMetric('cache_get', performance.now() - startTime, false);\n        return null;\n      }\n\n      // Update access statistics\n      entry.accessCount++;\n      entry.lastAccessed = Date.now();\n\n      // Update database asynchronously\n      this.db.cache.put(entry).catch(err => {\n        console.warn('Failed to update cache stats:', err);\n      });\n      this.cacheStats.hits++;\n      this.recordMetric('cache_get', performance.now() - startTime, true);\n      return entry.compressed ? this.decompress(entry.value) : entry.value;\n    } catch (error) {\n      console.error('Cache get error:', error);\n      this.cacheStats.misses++;\n      this.recordMetric('cache_get', performance.now() - startTime, false);\n      return null;\n    }\n  }\n  async delete(key) {\n    try {\n      this.memoryCache.delete(key);\n      await this.db.cache.where('key').equals(key).delete();\n      this.cacheStats.deletes++;\n      return true;\n    } catch (error) {\n      console.error('Cache delete error:', error);\n      return false;\n    }\n  }\n  async deleteByTags(tags) {\n    const tagsArray = Array.isArray(tags) ? tags : [tags];\n    try {\n      const entries = await this.db.cache.toArray();\n      const keysToDelete = entries.filter(entry => entry.tags.some(tag => tagsArray.includes(tag))).map(entry => entry.key);\n\n      // Delete from memory cache\n      keysToDelete.forEach(key => this.memoryCache.delete(key));\n\n      // Delete from database\n      await this.db.cache.where('key').anyOf(keysToDelete).delete();\n      this.cacheStats.deletes += keysToDelete.length;\n      return keysToDelete.length;\n    } catch (error) {\n      console.error('Cache delete by tags error:', error);\n      return 0;\n    }\n  }\n  async mget(keys) {\n    const results = {};\n    const promises = keys.map(async key => {\n      const value = await this.get(key);\n      results[key] = value;\n    });\n    await Promise.all(promises);\n    return results;\n  }\n  async mset(entries, options = {}) {\n    const promises = Object.entries(entries).map(([key, value]) => this.set(key, value, options));\n    const results = await Promise.all(promises);\n    return results.every(result => result === true);\n  }\n  async exists(key) {\n    try {\n      const entry = this.memoryCache.get(key) || (await this.db.cache.where('key').equals(key).first());\n      return entry && Date.now() <= entry.expiresAt;\n    } catch (error) {\n      console.error('Cache exists error:', error);\n      return false;\n    }\n  }\n  async keys(pattern = '*') {\n    try {\n      const allKeys = await this.db.cache.toCollection().primaryKeys();\n      if (pattern === '*') {\n        return allKeys;\n      }\n      const regex = new RegExp(pattern.replace(/\\*/g, '.*'));\n      return allKeys.filter(key => regex.test(key));\n    } catch (error) {\n      console.error('Cache keys error:', error);\n      return [];\n    }\n  }\n  async clear() {\n    try {\n      this.memoryCache.clear();\n      await this.db.cache.clear();\n      this.resetStats();\n      return true;\n    } catch (error) {\n      console.error('Cache clear error:', error);\n      return false;\n    }\n  }\n  async getStats() {\n    try {\n      const memorySize = this.memoryCache.size;\n      const dbSize = await this.db.cache.count();\n      const hitRate = this.cacheStats.hits / (this.cacheStats.hits + this.cacheStats.misses) || 0;\n      return {\n        ...this.cacheStats,\n        memorySize,\n        dbSize,\n        hitRate: Math.round(hitRate * 100) / 100,\n        memoryUsage: `${memorySize}/${this.maxMemorySize}`\n      };\n    } catch (error) {\n      console.error('Cache stats error:', error);\n      return this.cacheStats;\n    }\n  }\n  async cleanup() {\n    const now = Date.now();\n    try {\n      // Clean expired entries from memory\n      for (const [key, entry] of this.memoryCache.entries()) {\n        if (now > entry.expiresAt) {\n          this.memoryCache.delete(key);\n          this.cacheStats.evictions++;\n        }\n      }\n\n      // Clean expired entries from database\n      const expiredCount = await this.db.cache.where('expiresAt').below(now).delete();\n      this.cacheStats.evictions += expiredCount;\n      console.log(`Cache cleanup: removed ${expiredCount} expired entries`);\n    } catch (error) {\n      console.error('Cache cleanup error:', error);\n    }\n  }\n  enforceMemoryLimit() {\n    if (this.memoryCache.size <= this.maxMemorySize) {\n      return;\n    }\n\n    // LRU eviction - remove least recently accessed\n    const entries = Array.from(this.memoryCache.entries()).sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed);\n    const toRemove = entries.length - this.maxMemorySize;\n    for (let i = 0; i < toRemove; i++) {\n      this.memoryCache.delete(entries[i][0]);\n      this.cacheStats.evictions++;\n    }\n  }\n  compress(data) {\n    try {\n      return JSON.stringify(data);\n    } catch (error) {\n      console.warn('Compression failed:', error);\n      return data;\n    }\n  }\n  decompress(data) {\n    try {\n      return JSON.parse(data);\n    } catch (error) {\n      console.warn('Decompression failed:', error);\n      return data;\n    }\n  }\n  async recordMetric(operation, duration, success, metadata = {}) {\n    try {\n      await this.db.metrics.add({\n        operation,\n        duration,\n        success,\n        timestamp: Date.now(),\n        metadata\n      });\n    } catch (error) {\n      console.warn('Failed to record metric:', error);\n    }\n  }\n  resetStats() {\n    this.cacheStats = {\n      hits: 0,\n      misses: 0,\n      sets: 0,\n      deletes: 0,\n      evictions: 0\n    };\n  }\n  async getMetrics(timeRange = 3600000) {\n    try {\n      const since = Date.now() - timeRange;\n      const metrics = await this.db.metrics.where('timestamp').above(since).toArray();\n      const byOperation = metrics.reduce((acc, metric) => {\n        if (!acc[metric.operation]) {\n          acc[metric.operation] = {\n            count: 0,\n            totalDuration: 0,\n            successCount: 0,\n            failureCount: 0\n          };\n        }\n        acc[metric.operation].count++;\n        acc[metric.operation].totalDuration += metric.duration;\n        if (metric.success) {\n          acc[metric.operation].successCount++;\n        } else {\n          acc[metric.operation].failureCount++;\n        }\n        return acc;\n      }, {});\n\n      // Calculate averages\n      Object.keys(byOperation).forEach(operation => {\n        const stats = byOperation[operation];\n        stats.avgDuration = stats.totalDuration / stats.count;\n        stats.successRate = stats.successCount / stats.count;\n      });\n      return byOperation;\n    } catch (error) {\n      console.error('Failed to get metrics:', error);\n      return {};\n    }\n  }\n  async cacheCalculation(sqft, result) {\n    const key = `calculation:${sqft}`;\n    const cacheEntry = {\n      sqft,\n      ...result,\n      timestamp: Date.now()\n    };\n    await Promise.all([this.set(key, cacheEntry, {\n      ttl: 3600000,\n      // 1 hour\n      tags: ['calculations']\n    }), this.db.calculations.add(cacheEntry)]);\n  }\n  async getCachedCalculation(sqft) {\n    const key = `calculation:${sqft}`;\n    return await this.get(key);\n  }\n  destroy() {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n    }\n    this.memoryCache.clear();\n    this.db.close();\n  }\n}\nconst cacheManager = new AdvancedCacheManager();\nexport default cacheManager;\nexport { AdvancedCacheManager };","map":{"version":3,"names":["Dexie","AdvancedCacheManager","constructor","db","initializeDatabase","initializeInMemoryCache","version","stores","cache","sessions","calculations","metrics","open","catch","err","console","error","memoryCache","Map","cacheStats","hits","misses","sets","deletes","evictions","maxMemorySize","cleanupInterval","setInterval","cleanup","set","key","value","options","ttl","tags","priority","compress","now","Date","expiresAt","cacheEntry","createdAt","accessCount","lastAccessed","Array","isArray","compressed","enforceMemoryLimit","put","get","startTime","performance","entry","dbEntry","where","equals","first","recordMetric","delete","warn","decompress","deleteByTags","tagsArray","entries","toArray","keysToDelete","filter","some","tag","includes","map","forEach","anyOf","length","mget","keys","results","promises","Promise","all","mset","Object","every","result","exists","pattern","allKeys","toCollection","primaryKeys","regex","RegExp","replace","test","clear","resetStats","getStats","memorySize","size","dbSize","count","hitRate","Math","round","memoryUsage","expiredCount","below","log","from","sort","a","b","toRemove","i","data","JSON","stringify","parse","operation","duration","success","metadata","add","timestamp","getMetrics","timeRange","since","above","byOperation","reduce","acc","metric","totalDuration","successCount","failureCount","stats","avgDuration","successRate","cacheCalculation","sqft","getCachedCalculation","destroy","clearInterval","close","cacheManager"],"sources":["C:/Users/PC_User/Desktop/free-crm/bhotch-crm/src/utils/advancedCache.js"],"sourcesContent":["import Dexie from 'dexie';\r\n\r\nclass AdvancedCacheManager {\r\n  constructor() {\r\n    this.db = new Dexie('UltimateCRMCache');\r\n    this.initializeDatabase();\r\n    this.initializeInMemoryCache();\r\n  }\r\n\r\n  initializeDatabase() {\r\n    this.db.version(1).stores({\r\n      cache: '++id, key, value, expiresAt, createdAt, accessCount, lastAccessed, tags',\r\n      sessions: '++id, sessionId, data, expiresAt, createdAt',\r\n      calculations: '++id, sqft, ridgeVents, turbineVents, rimeFlow, method, timestamp',\r\n      metrics: '++id, operation, duration, success, timestamp, metadata'\r\n    });\r\n\r\n    this.db.open().catch(err => {\r\n      console.error('Failed to open cache database:', err);\r\n    });\r\n  }\r\n\r\n  initializeInMemoryCache() {\r\n    this.memoryCache = new Map();\r\n    this.cacheStats = {\r\n      hits: 0,\r\n      misses: 0,\r\n      sets: 0,\r\n      deletes: 0,\r\n      evictions: 0\r\n    };\r\n    this.maxMemorySize = 1000;\r\n    this.cleanupInterval = setInterval(() => this.cleanup(), 300000);\r\n  }\r\n\r\n  async set(key, value, options = {}) {\r\n    const {\r\n      ttl = 3600000, // 1 hour default\r\n      tags = [],\r\n      priority = 1,\r\n      compress = false\r\n    } = options;\r\n\r\n    const now = Date.now();\r\n    const expiresAt = now + ttl;\r\n\r\n    const cacheEntry = {\r\n      key,\r\n      value: compress ? this.compress(value) : value,\r\n      expiresAt,\r\n      createdAt: now,\r\n      accessCount: 0,\r\n      lastAccessed: now,\r\n      tags: Array.isArray(tags) ? tags : [tags],\r\n      priority,\r\n      compressed: compress\r\n    };\r\n\r\n    try {\r\n      // Store in memory cache for fast access\r\n      this.memoryCache.set(key, cacheEntry);\r\n      this.enforceMemoryLimit();\r\n\r\n      // Store in persistent database\r\n      await this.db.cache.put(cacheEntry);\r\n\r\n      this.cacheStats.sets++;\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Cache set error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async get(key) {\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      // Check memory cache first\r\n      let entry = this.memoryCache.get(key);\r\n\r\n      // If not in memory, check database\r\n      if (!entry) {\r\n        const dbEntry = await this.db.cache.where('key').equals(key).first();\r\n        if (dbEntry) {\r\n          entry = dbEntry;\r\n          // Add to memory cache for future access\r\n          this.memoryCache.set(key, entry);\r\n        }\r\n      }\r\n\r\n      if (!entry) {\r\n        this.cacheStats.misses++;\r\n        this.recordMetric('cache_get', performance.now() - startTime, false);\r\n        return null;\r\n      }\r\n\r\n      // Check expiration\r\n      if (Date.now() > entry.expiresAt) {\r\n        await this.delete(key);\r\n        this.cacheStats.misses++;\r\n        this.recordMetric('cache_get', performance.now() - startTime, false);\r\n        return null;\r\n      }\r\n\r\n      // Update access statistics\r\n      entry.accessCount++;\r\n      entry.lastAccessed = Date.now();\r\n\r\n      // Update database asynchronously\r\n      this.db.cache.put(entry).catch(err => {\r\n        console.warn('Failed to update cache stats:', err);\r\n      });\r\n\r\n      this.cacheStats.hits++;\r\n      this.recordMetric('cache_get', performance.now() - startTime, true);\r\n\r\n      return entry.compressed ? this.decompress(entry.value) : entry.value;\r\n    } catch (error) {\r\n      console.error('Cache get error:', error);\r\n      this.cacheStats.misses++;\r\n      this.recordMetric('cache_get', performance.now() - startTime, false);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async delete(key) {\r\n    try {\r\n      this.memoryCache.delete(key);\r\n      await this.db.cache.where('key').equals(key).delete();\r\n      this.cacheStats.deletes++;\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Cache delete error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async deleteByTags(tags) {\r\n    const tagsArray = Array.isArray(tags) ? tags : [tags];\r\n\r\n    try {\r\n      const entries = await this.db.cache.toArray();\r\n      const keysToDelete = entries\r\n        .filter(entry => entry.tags.some(tag => tagsArray.includes(tag)))\r\n        .map(entry => entry.key);\r\n\r\n      // Delete from memory cache\r\n      keysToDelete.forEach(key => this.memoryCache.delete(key));\r\n\r\n      // Delete from database\r\n      await this.db.cache.where('key').anyOf(keysToDelete).delete();\r\n\r\n      this.cacheStats.deletes += keysToDelete.length;\r\n      return keysToDelete.length;\r\n    } catch (error) {\r\n      console.error('Cache delete by tags error:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  async mget(keys) {\r\n    const results = {};\r\n    const promises = keys.map(async key => {\r\n      const value = await this.get(key);\r\n      results[key] = value;\r\n    });\r\n\r\n    await Promise.all(promises);\r\n    return results;\r\n  }\r\n\r\n  async mset(entries, options = {}) {\r\n    const promises = Object.entries(entries).map(([key, value]) =>\r\n      this.set(key, value, options)\r\n    );\r\n\r\n    const results = await Promise.all(promises);\r\n    return results.every(result => result === true);\r\n  }\r\n\r\n  async exists(key) {\r\n    try {\r\n      const entry = this.memoryCache.get(key) ||\r\n        await this.db.cache.where('key').equals(key).first();\r\n\r\n      return entry && Date.now() <= entry.expiresAt;\r\n    } catch (error) {\r\n      console.error('Cache exists error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async keys(pattern = '*') {\r\n    try {\r\n      const allKeys = await this.db.cache.toCollection().primaryKeys();\r\n\r\n      if (pattern === '*') {\r\n        return allKeys;\r\n      }\r\n\r\n      const regex = new RegExp(pattern.replace(/\\*/g, '.*'));\r\n      return allKeys.filter(key => regex.test(key));\r\n    } catch (error) {\r\n      console.error('Cache keys error:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async clear() {\r\n    try {\r\n      this.memoryCache.clear();\r\n      await this.db.cache.clear();\r\n      this.resetStats();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Cache clear error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async getStats() {\r\n    try {\r\n      const memorySize = this.memoryCache.size;\r\n      const dbSize = await this.db.cache.count();\r\n      const hitRate = this.cacheStats.hits / (this.cacheStats.hits + this.cacheStats.misses) || 0;\r\n\r\n      return {\r\n        ...this.cacheStats,\r\n        memorySize,\r\n        dbSize,\r\n        hitRate: Math.round(hitRate * 100) / 100,\r\n        memoryUsage: `${memorySize}/${this.maxMemorySize}`\r\n      };\r\n    } catch (error) {\r\n      console.error('Cache stats error:', error);\r\n      return this.cacheStats;\r\n    }\r\n  }\r\n\r\n  async cleanup() {\r\n    const now = Date.now();\r\n\r\n    try {\r\n      // Clean expired entries from memory\r\n      for (const [key, entry] of this.memoryCache.entries()) {\r\n        if (now > entry.expiresAt) {\r\n          this.memoryCache.delete(key);\r\n          this.cacheStats.evictions++;\r\n        }\r\n      }\r\n\r\n      // Clean expired entries from database\r\n      const expiredCount = await this.db.cache\r\n        .where('expiresAt')\r\n        .below(now)\r\n        .delete();\r\n\r\n      this.cacheStats.evictions += expiredCount;\r\n\r\n      console.log(`Cache cleanup: removed ${expiredCount} expired entries`);\r\n    } catch (error) {\r\n      console.error('Cache cleanup error:', error);\r\n    }\r\n  }\r\n\r\n  enforceMemoryLimit() {\r\n    if (this.memoryCache.size <= this.maxMemorySize) {\r\n      return;\r\n    }\r\n\r\n    // LRU eviction - remove least recently accessed\r\n    const entries = Array.from(this.memoryCache.entries())\r\n      .sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed);\r\n\r\n    const toRemove = entries.length - this.maxMemorySize;\r\n    for (let i = 0; i < toRemove; i++) {\r\n      this.memoryCache.delete(entries[i][0]);\r\n      this.cacheStats.evictions++;\r\n    }\r\n  }\r\n\r\n  compress(data) {\r\n    try {\r\n      return JSON.stringify(data);\r\n    } catch (error) {\r\n      console.warn('Compression failed:', error);\r\n      return data;\r\n    }\r\n  }\r\n\r\n  decompress(data) {\r\n    try {\r\n      return JSON.parse(data);\r\n    } catch (error) {\r\n      console.warn('Decompression failed:', error);\r\n      return data;\r\n    }\r\n  }\r\n\r\n  async recordMetric(operation, duration, success, metadata = {}) {\r\n    try {\r\n      await this.db.metrics.add({\r\n        operation,\r\n        duration,\r\n        success,\r\n        timestamp: Date.now(),\r\n        metadata\r\n      });\r\n    } catch (error) {\r\n      console.warn('Failed to record metric:', error);\r\n    }\r\n  }\r\n\r\n  resetStats() {\r\n    this.cacheStats = {\r\n      hits: 0,\r\n      misses: 0,\r\n      sets: 0,\r\n      deletes: 0,\r\n      evictions: 0\r\n    };\r\n  }\r\n\r\n  async getMetrics(timeRange = 3600000) {\r\n    try {\r\n      const since = Date.now() - timeRange;\r\n      const metrics = await this.db.metrics\r\n        .where('timestamp')\r\n        .above(since)\r\n        .toArray();\r\n\r\n      const byOperation = metrics.reduce((acc, metric) => {\r\n        if (!acc[metric.operation]) {\r\n          acc[metric.operation] = {\r\n            count: 0,\r\n            totalDuration: 0,\r\n            successCount: 0,\r\n            failureCount: 0\r\n          };\r\n        }\r\n\r\n        acc[metric.operation].count++;\r\n        acc[metric.operation].totalDuration += metric.duration;\r\n\r\n        if (metric.success) {\r\n          acc[metric.operation].successCount++;\r\n        } else {\r\n          acc[metric.operation].failureCount++;\r\n        }\r\n\r\n        return acc;\r\n      }, {});\r\n\r\n      // Calculate averages\r\n      Object.keys(byOperation).forEach(operation => {\r\n        const stats = byOperation[operation];\r\n        stats.avgDuration = stats.totalDuration / stats.count;\r\n        stats.successRate = stats.successCount / stats.count;\r\n      });\r\n\r\n      return byOperation;\r\n    } catch (error) {\r\n      console.error('Failed to get metrics:', error);\r\n      return {};\r\n    }\r\n  }\r\n\r\n  async cacheCalculation(sqft, result) {\r\n    const key = `calculation:${sqft}`;\r\n    const cacheEntry = {\r\n      sqft,\r\n      ...result,\r\n      timestamp: Date.now()\r\n    };\r\n\r\n    await Promise.all([\r\n      this.set(key, cacheEntry, {\r\n        ttl: 3600000, // 1 hour\r\n        tags: ['calculations']\r\n      }),\r\n      this.db.calculations.add(cacheEntry)\r\n    ]);\r\n  }\r\n\r\n  async getCachedCalculation(sqft) {\r\n    const key = `calculation:${sqft}`;\r\n    return await this.get(key);\r\n  }\r\n\r\n  destroy() {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n    }\r\n    this.memoryCache.clear();\r\n    this.db.close();\r\n  }\r\n}\r\n\r\nconst cacheManager = new AdvancedCacheManager();\r\n\r\nexport default cacheManager;\r\nexport { AdvancedCacheManager };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}